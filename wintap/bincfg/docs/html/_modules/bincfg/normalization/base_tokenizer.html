<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>bincfg.normalization.base_tokenizer &mdash; BinCFG 0.1.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> BinCFG
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../bincfg.cfg.html">bincfg.cfg package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bincfg.utils.html">bincfg.utils package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bincfg.normalization.html">bincfg.normalization package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bincfg.labeling.html">bincfg.labeling package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">BinCFG</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">bincfg.normalization.base_tokenizer</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for bincfg.normalization.base_tokenizer</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Class for tokenizing assembly lines&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">.tokenization_constants</span> <span class="kn">import</span> <span class="n">Tokens</span><span class="p">,</span> <span class="n">DEFAULT_TOKENS</span><span class="p">,</span> <span class="n">TokenMismatchError</span><span class="p">,</span> <span class="n">RE_INSTRUCTION_PREFIX_CODES</span><span class="p">,</span> \
    <span class="n">RE_BRANCH_PREDICTION</span>
<span class="kn">from</span> <span class="nn">.norm_utils</span> <span class="kn">import</span> <span class="n">clean_incoming_instruction</span>
<span class="kn">from</span> <span class="nn">.check_asm</span> <span class="kn">import</span> <span class="n">check_assembly_rules</span>


<span class="n">_DEFAULT_ENFORCE</span> <span class="o">=</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">_set_default_enforce_asm_rules</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sets the default enforce_asm_rules parameter used during tokenization&quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_DEFAULT_ENFORCE</span>
    <span class="n">_DEFAULT_ENFORCE</span> <span class="o">=</span> <span class="n">val</span>


<div class="viewcode-block" id="BaseTokenizer"><a class="viewcode-back" href="../../../bincfg.normalization.html#bincfg.normalization.base_tokenizer.BaseTokenizer">[docs]</a><span class="k">class</span> <span class="nc">BaseTokenizer</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A default class to tokenize assembly line input</span>

<span class="sd">    Currently, this tokenization schema can handle outputs from:</span>

<span class="sd">        * rose disassembly</span>
<span class="sd">        * ghidra disassembly (in BB data)</span>
<span class="sd">    </span>
<span class="sd">    The tokenizer will tokenize essentially anything, so long as it fits known tokens.</span>

<span class="sd">    Known Tokens:</span>

<span class="sd">        * Instruction start token: used for op-level normalization techniques</span>
<span class="sd">        * Instruction address: the address sometimes present and only at the very start of the instruction that is used to</span>
<span class="sd">          specify the address of that instruction. Should be an immediate value</span>
<span class="sd">        * Newline token: used to specify new instructions in case multiple instructions are being tokenized in one string.</span>
<span class="sd">          Can be a newline character or a pipe character &#39;|&#39;</span>
<span class="sd">        * Rose Information: Any information contained within &lt;&gt; brackets is considered rose information (including the brackets)</span>
<span class="sd">        * Spacing: one or more spaces, tabs, or commas in a row. Can also be the characters &#39;.&#39; and &#39;_&#39; when used as delimiters</span>
<span class="sd">          for instruction prefixes built onto opcodes (see below)</span>
<span class="sd">        * PTR: the literal string &#39;ptr&#39; that appears in some memory accesses (EG: dword ptr [...])</span>
<span class="sd">        * Single character tokens used for memory accesses: &#39;[&#39;, &#39;]&#39;, &#39;+&#39;, &#39;*&#39;</span>
<span class="sd">        * Instruction prefixes: lock, rep, repne, etc. These can appear as plain string separated by spacing, or attatched</span>
<span class="sd">          to opcodes. If attatched to an opcode, its order does not matter, and it must be delimited by either a &#39;.&#39; or a</span>
<span class="sd">          &#39;_&#39;. If this occurs, there can only be one opcode, and all of the other substrings must be known instruction</span>
<span class="sd">          prefixes</span>
<span class="sd">        * Branch prediction tokens: the literal strings &#39;,pt&#39; and &#39;,pn&#39; for branch predictions. Must come immediately</span>
<span class="sd">          following an opcode (or opcode + attatched instruction prefix(es)) if present</span>
<span class="sd">        * Segment addresses: far-jump address information, eg: &quot;fs:0x123456&quot;</span>
<span class="sd">        * Immediate values: can be in binary, octal, decimal, and hex</span>
<span class="sd">        * Segment token: memory segment specifier used for memory accesses, eg: &quot;qword ptr ds:[...]&quot;, the &quot;ds:&quot; bit</span>
<span class="sd">        * Memory size: tokens that specify memory access size, eg: &quot;qword&quot;, &quot;dword&quot;, &quot;byte&quot;, etc.</span>
<span class="sd">        * Registers: known register names</span>
<span class="sd">        * Opcodes: any string of alphabet characters that does not fit one of the tokens above is considered an opcode</span>

<span class="sd">    Anything that does not fit one of the above tokens will be considered a &#39;token mismatch&#39;</span>

<span class="sd">    This will do the following transformations to the incomming token stream:</span>

<span class="sd">        * Any instruction prefixes or branch predictions will be moved to immediately before their opcode in the same order</span>
<span class="sd">          that they appear in the string (separated by the same spacings that were used before them in the original string). </span>
<span class="sd">          This means any branch prediction will be immediately before the opcode and after any other instruction prefixes </span>
<span class="sd">          since they can only appear at the end of opcode + prefix strings</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tokens: `List[Tuple[str, str]]`</span>
<span class="sd">        the tokens to use. Should be a list of 2-tuples. Each tuple is a pair of (name, regex) where</span>
<span class="sd">        name is the string name of the token, and regex is a regular expression to find that token. These</span>
<span class="sd">        tuples should be ordered in the preferred order to search for tokens with a &#39;mismatch&#39; token matching</span>
<span class="sd">        all characters at the very end to find mismatch lines. Defaults to `bincfg.normalization.tokenization_constants.DEFAULT_TOKENS`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">DEFAULT_NEWLINE_TUPLE</span> <span class="o">=</span> <span class="p">(</span><span class="n">Tokens</span><span class="o">.</span><span class="n">NEWLINE</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;The default (token_name, token) tuple to use for newlines&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="o">=</span><span class="n">DEFAULT_TOKENS</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span> <span class="o">=</span> <span class="n">tokens</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([(</span><span class="s2">&quot;(?P&lt;</span><span class="si">%s</span><span class="s2">&gt;</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="n">pair</span><span class="p">)</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">]),</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>

<div class="viewcode-block" id="BaseTokenizer.tokenize"><a class="viewcode-back" href="../../../bincfg.normalization.html#bincfg.normalization.base_tokenizer.BaseTokenizer.tokenize">[docs]</a>    <span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">strings</span><span class="p">,</span> <span class="n">enforce_asm_rules</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">newline_tup</span><span class="o">=</span><span class="n">DEFAULT_NEWLINE_TUPLE</span><span class="p">,</span> <span class="n">match_instruction_address</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tokenizes some number of strings in the order they were recieved returning a list of 2-tuples. </span>
<span class="sd">        </span>
<span class="sd">        Each tuple is (name, token) where name is the string name of the token, and token is the substring in the given </span>
<span class="sd">        string corresponding to that token. Extra &#39;newline&#39; tuples will be added inbetween each string.</span>

<span class="sd">        Initially cleans the string. See :func:`~bincfg.normalization.norm_utils.clean_incoming_instruction` for more details.</span>

<span class="sd">        Also pulls prefixes out of opcodes. See top of file for possible placements of instruction prefixes. These prefixes</span>
<span class="sd">        are returned in order before the opcode, with no extra newlines or anything.</span>

<span class="sd">        Args:</span>
<span class="sd">            strings (str): arbitrary number of strings to tokenize.</span>
<span class="sd">            enforce_asm_rules (Optional[bool]): if True, then extra processing and checks will be done to make sure the </span>
<span class="sd">                tokenized assembly language matches the rules of assembly. See self.check_assembly_rules() for more info. </span>
<span class="sd">                If False, these checks aren&#39;t done and bad assembly could make its way through without error, but should </span>
<span class="sd">                be noticeably faster. If None, will use the default value. The default value starts as False at the</span>
<span class="sd">                beginning of program execution but can be modified using </span>
<span class="sd">                :func:`~bincfg.normalization.base_tokenizer._set_default_enforce_asm_rules`</span>
<span class="sd">            newline_tup (Tuple[str, str], optional): the tuple to insert inbetween each passed string, or None to not </span>
<span class="sd">                insert anything. Defaults to `self.__class__.DEFAULT_NEWLINE_TUPLE`.</span>
<span class="sd">            match_instruction_address (bool, optional): if True, will assume there will be an instruction address at the </span>
<span class="sd">                start of the string. This only has an effect on ghidra-like instruction addresses where that address </span>
<span class="sd">                could be interpreted as either an immediate, or an instruction address. If True, then any immediates </span>
<span class="sd">                found at the start of a line will be assumed to be instruction addresses instead of immediates. If False,</span>
<span class="sd">                then instruction addresses can still be matched, but they must end with a colon &#39;:&#39;, otherwise they will </span>
<span class="sd">                be considered immediates. Defaults to True.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TokenMismatchError: on a bad branch prediction string</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[Tuple[str, str]]: list of (token_name, token) tuples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">enforce_asm_rules</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">enforce_asm_rules</span> <span class="o">=</span> <span class="n">_DEFAULT_ENFORCE</span>
        
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># This is a weird mess of things, but it works. Maybe I&#39;ll clean it later...</span>
        <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="n">strings</span><span class="p">:</span>
            <span class="n">previous_newline</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">clean_string</span> <span class="o">=</span> <span class="n">clean_incoming_instruction</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
            <span class="n">app</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># So we don&#39;t have to do the reorganizing every time</span>
            <span class="n">reorganize_tokens</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">for</span> <span class="n">mo</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">clean_string</span><span class="p">):</span>
                <span class="n">name</span><span class="p">,</span> <span class="n">token</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">lastgroup</span><span class="p">,</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
                <span class="n">add_after</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">MISMATCH</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">on_token_mismatch</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">mo</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">OPCODE</span><span class="p">:</span>

                    <span class="c1"># For now, we will leave all instruction prefixes and opcodes in their original position (for error checking later)</span>
                    <span class="c1"># Leave the original token as-is for error messages</span>
                    <span class="n">total_token</span> <span class="o">=</span> <span class="n">token</span>

                    <span class="c1"># If the token ends with commas, then consider those spacing</span>
                    <span class="k">if</span> <span class="n">total_token</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;,&#39;</span><span class="p">:</span>
                        <span class="n">num_commas</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_token</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;,+$&#39;</span><span class="p">,</span> <span class="n">total_token</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">add_after</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">Tokens</span><span class="o">.</span><span class="n">SPACING</span><span class="p">,</span> <span class="s1">&#39;,&#39;</span> <span class="o">*</span> <span class="n">num_commas</span><span class="p">))</span>
                        <span class="n">total_token</span> <span class="o">=</span> <span class="n">total_token</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">total_token</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_commas</span><span class="p">]</span>

                    <span class="c1"># Check for something with spacing at the start/end</span>
                    <span class="k">if</span> <span class="n">total_token</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s1">&#39;._&#39;</span> <span class="ow">or</span> <span class="n">total_token</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="s1">&#39;._&#39;</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">TokenMismatchError</span><span class="p">(</span><span class="s2">&quot;Found an opcode + instruction prefix string that either starts or ends &quot;</span>
                                                 <span class="s2">&quot;with a non-whitespace spacing token: </span><span class="si">%s</span><span class="s2">, in string: </span><span class="si">%s</span><span class="s2">&quot;</span> 
                                                 <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">token</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">string</span><span class="p">)))</span>
                    
                    <span class="c1"># If there are multiple commas, then consider those multiple attempted branch predictions, which is invalid</span>
                    <span class="k">if</span> <span class="n">total_token</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">TokenMismatchError</span><span class="p">(</span><span class="s2">&quot;Found multiple occurances of &#39;,&#39; used for branch predictions in token &quot;</span>
                                                 <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">, only one branch prediction token is allowed. In string: </span><span class="si">%s</span><span class="s2">&quot;</span> 
                                                 <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">token</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">string</span><span class="p">)))</span>

                    <span class="c1"># Pull out the branch prediction, which should only be at the end</span>
                    <span class="k">if</span> <span class="s1">&#39;,&#39;</span> <span class="ow">in</span> <span class="n">total_token</span><span class="p">:</span>
                        <span class="n">reorganize_tokens</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">total_token</span><span class="p">,</span> <span class="n">branch_pred</span> <span class="o">=</span> <span class="n">token</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>

                        <span class="c1"># Check that it is a known branch prediction</span>
                        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="n">RE_BRANCH_PREDICTION</span><span class="p">,</span> <span class="n">branch_pred</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">TokenMismatchError</span><span class="p">(</span><span class="s2">&quot;Found an unknown branch prediction token </span><span class="si">%s</span><span class="s2"> in string: </span><span class="si">%s</span><span class="s2">&quot;</span>
                                                     <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">branch_pred</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">string</span><span class="p">)))</span>
                        
                        <span class="n">add_after</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">Tokens</span><span class="o">.</span><span class="n">SPACING</span><span class="p">,</span> <span class="s1">&#39;,&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">Tokens</span><span class="o">.</span><span class="n">BRANCH_PREDICTION</span><span class="p">,</span> <span class="n">branch_pred</span><span class="p">)]</span>
                    
                    <span class="c1"># Now split on any &#39;.&#39; and &#39;_&#39;, capturing them. Add an extra spacing for the loop</span>
                    <span class="n">op_pre_splits</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;([._])&#39;</span><span class="p">,</span> <span class="n">total_token</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span>
                    
                    <span class="n">prefixes_after</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">opcode</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">in_pre</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">op_pre_splits</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">):</span>
                        <span class="n">curr_token</span><span class="p">,</span> <span class="n">spacing</span> <span class="o">=</span> <span class="n">op_pre_splits</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">],</span> <span class="n">op_pre_splits</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="n">spacing_arr</span> <span class="o">=</span> <span class="p">[(</span><span class="n">Tokens</span><span class="o">.</span><span class="n">SPACING</span><span class="p">,</span> <span class="n">spacing</span><span class="p">)]</span> <span class="k">if</span> <span class="n">spacing</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="p">[]</span>

                        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="n">RE_INSTRUCTION_PREFIX_CODES</span><span class="p">,</span> <span class="n">curr_token</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">reorganize_tokens</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="n">prefix_arr</span> <span class="o">=</span> <span class="p">[(</span><span class="n">Tokens</span><span class="o">.</span><span class="n">INSTRUCTION_PREFIX</span><span class="p">,</span> <span class="n">curr_token</span><span class="p">)]</span> <span class="o">+</span> <span class="n">spacing_arr</span>
                            <span class="k">if</span> <span class="n">in_pre</span><span class="p">:</span>
                                <span class="n">app</span> <span class="o">+=</span> <span class="n">prefix_arr</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">prefixes_after</span> <span class="o">+=</span> <span class="n">prefix_arr</span>
                        
                        <span class="c1"># Otherwise we have an opcode, check to make sure it is the only one</span>
                        <span class="k">elif</span> <span class="n">opcode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">TokenMismatchError</span><span class="p">(</span><span class="s2">&quot;Cannot have multiple opcodes in a single opcode + instruction &quot;</span>
                                                     <span class="s2">&quot;prefix token. In subtoken </span><span class="si">%s</span><span class="s2"> within token </span><span class="si">%s</span><span class="s2">, in string </span><span class="si">%s</span><span class="s2">&quot;</span> 
                                                     <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">curr_token</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">token</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">string</span><span class="p">)))</span>
                        
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">opcode</span> <span class="o">=</span> <span class="n">curr_token</span>
                            <span class="n">prefixes_after</span> <span class="o">+=</span> <span class="n">spacing_arr</span>
                            <span class="n">in_pre</span> <span class="o">=</span> <span class="kc">False</span>
                    
                    <span class="c1"># Add the prefixes_after to add_after, before branch prediction</span>
                    <span class="n">add_after</span> <span class="o">=</span> <span class="n">prefixes_after</span> <span class="o">+</span> <span class="n">add_after</span>

                    <span class="c1"># Set token to our final opcode</span>
                    <span class="n">token</span> <span class="o">=</span> <span class="n">opcode</span>

                <span class="c1"># If this is an immediate after newline (non-negative hex), then it should be an instruction address if match_instruction_address is True</span>
                <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">IMMEDIATE</span> <span class="ow">and</span> <span class="n">previous_newline</span> <span class="ow">and</span> <span class="n">match_instruction_address</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">token</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;-&#39;</span> <span class="ow">and</span> <span class="n">token</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>  
                    <span class="n">name</span> <span class="o">=</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">INSTRUCTION_ADDRESS</span>
                
                <span class="c1"># If this is an instruction address without a colon and match_instruction_address is False, consider it an immediate</span>
                <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">INSTRUCTION_ADDRESS</span> <span class="ow">and</span> <span class="n">token</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;:&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">match_instruction_address</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">IMMEDIATE</span>
                

                <span class="c1"># No matter what, if this is an instruction prefix, reorganize the tokens</span>
                <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">INSTRUCTION_PREFIX</span><span class="p">:</span>
                    <span class="n">reorganize_tokens</span> <span class="o">=</span> <span class="kc">True</span>
                
                <span class="n">previous_newline</span> <span class="o">=</span> <span class="n">name</span> <span class="o">==</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">NEWLINE</span>  <span class="c1"># Now we can switch previous_newline around if needed</span>
                <span class="n">app</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">token</span><span class="p">))</span>
                <span class="n">app</span> <span class="o">+=</span> <span class="n">add_after</span>

            <span class="k">if</span> <span class="n">newline_tup</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">app</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newline_tup</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">reorganize_tokens</span><span class="p">:</span>
                <span class="c1"># Move all instruction prefixes to the front before the opcode, including branch prediction at the end of them</span>
                <span class="c1"># Do this after the check_assembly_rules since that wants the tokens in the same order for error checking</span>
                <span class="n">final_app</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">opcode</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">found_prefix</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">only_prefix</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">prefix_spacing</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">token_type</span><span class="p">,</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">app</span><span class="p">:</span>
                    
                    <span class="c1"># Make sure we can&#39;t accidentally override opcodes, eg: &quot;lock opcode1 opcode2&quot;</span>
                    <span class="c1"># Otherwise if we have already found an opcode before, this new opcode should break us out of looking for</span>
                    <span class="c1">#   instruction prefixes for the first opcode, and instead start looking at the second one</span>
                    <span class="k">if</span> <span class="n">token_type</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Tokens</span><span class="o">.</span><span class="n">OPCODE</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">opcode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">final_app</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">opcode</span><span class="p">)</span>
                            <span class="n">prefix_spacing</span> <span class="o">=</span> <span class="n">final_app</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prefix_spacing</span><span class="p">)</span> <span class="k">if</span> <span class="n">prefix_spacing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>  <span class="c1"># Heh</span>
                        <span class="n">opcode</span> <span class="o">=</span> <span class="p">(</span><span class="n">token_type</span><span class="p">,</span> <span class="n">token</span><span class="p">)</span>
                        <span class="n">only_prefix</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">continue</span>

                    <span class="c1"># If this is one of the spacings used after opcodes for instruction prefixes (&#39;.&#39; and &#39;_&#39; and &#39;,&#39;), then keep</span>
                    <span class="c1">#   track of it to possibly put it after the next instruction prefix.</span>
                    <span class="c1"># Make sure there isn&#39;t already a prefix spacing</span>
                    <span class="k">elif</span> <span class="n">token_type</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Tokens</span><span class="o">.</span><span class="n">SPACING</span><span class="p">]</span> <span class="ow">and</span> <span class="n">token</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39;,&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">opcode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">prefix_spacing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">prefix_spacing</span> <span class="o">=</span> <span class="p">(</span><span class="n">token_type</span><span class="p">,</span> <span class="n">token</span><span class="p">)</span>
                        <span class="k">continue</span>
                    
                    <span class="c1"># Otherwise if this token is an instruction prefix and we have an active opcode, add it and any spacing</span>
                    <span class="k">elif</span> <span class="n">token_type</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Tokens</span><span class="o">.</span><span class="n">INSTRUCTION_PREFIX</span><span class="p">,</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">BRANCH_PREDICTION</span><span class="p">]</span> <span class="ow">and</span> <span class="n">opcode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">found_prefix</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">final_app</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">token_type</span><span class="p">,</span> <span class="n">token</span><span class="p">))</span>
                        <span class="n">prefix_spacing</span> <span class="o">=</span> <span class="n">final_app</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prefix_spacing</span><span class="p">)</span> <span class="k">if</span> <span class="n">prefix_spacing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>  <span class="c1"># Heh</span>
                        <span class="k">continue</span>
                    
                    <span class="c1"># Otherwise we have no more instruction prefixes. Add opcode/spacing if needed, and add this token normally</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">opcode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">opcode</span> <span class="o">=</span> <span class="n">final_app</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">opcode</span><span class="p">)</span>
                            <span class="n">prefix_spacing</span> <span class="o">=</span> <span class="n">final_app</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prefix_spacing</span><span class="p">)</span> <span class="k">if</span> <span class="n">prefix_spacing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>  <span class="c1"># Heh</span>
                        
                        <span class="c1"># If this is a newline token, check if we should merge this line into the next one because it</span>
                        <span class="c1">#   only contains instruction prefixes</span>
                        <span class="k">if</span> <span class="n">token_type</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Tokens</span><span class="o">.</span><span class="n">NEWLINE</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">found_prefix</span> <span class="ow">and</span> <span class="n">only_prefix</span><span class="p">:</span>
                                <span class="n">found_prefix</span> <span class="o">=</span> <span class="kc">False</span>
                                <span class="n">final_app</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">Tokens</span><span class="o">.</span><span class="n">SPACING</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">))</span>
                                <span class="k">continue</span>

                            <span class="n">found_prefix</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="n">only_prefix</span> <span class="o">=</span> <span class="kc">True</span>
                        
                        <span class="k">elif</span> <span class="n">token_type</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Tokens</span><span class="o">.</span><span class="n">INSTRUCTION_PREFIX</span><span class="p">,</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">BRANCH_PREDICTION</span><span class="p">]:</span>
                            <span class="n">found_prefix</span> <span class="o">=</span> <span class="kc">True</span>
                        
                        <span class="k">elif</span> <span class="n">token_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Tokens</span><span class="o">.</span><span class="n">SPACING</span><span class="p">,</span> <span class="n">Tokens</span><span class="o">.</span><span class="n">ROSE_INFO</span><span class="p">]:</span>
                            <span class="n">only_prefix</span> <span class="o">=</span> <span class="kc">False</span>
                    
                        <span class="n">final_app</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">token_type</span><span class="p">,</span> <span class="n">token</span><span class="p">))</span>
            
            <span class="k">else</span><span class="p">:</span>
                <span class="n">final_app</span> <span class="o">=</span> <span class="n">app</span>
        
            <span class="c1"># Check the assembly is correct if using</span>
            <span class="k">if</span> <span class="n">enforce_asm_rules</span><span class="p">:</span>
                <span class="n">check_assembly_rules</span><span class="p">(</span><span class="n">final_app</span><span class="p">,</span> <span class="n">app</span><span class="p">,</span> <span class="n">clean_string</span><span class="p">,</span> <span class="n">newline_tup</span><span class="p">)</span>
            
            <span class="n">ret</span> <span class="o">+=</span> <span class="n">final_app</span>

        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">strings</span><span class="p">,</span> <span class="n">enforce_asm_rules</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">newline_tup</span><span class="o">=</span><span class="n">DEFAULT_NEWLINE_TUPLE</span><span class="p">,</span> <span class="n">match_instruction_address</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tokenizes some number of strings in the order they were recieved returning a list of 2-tuples. </span>
<span class="sd">        </span>
<span class="sd">        Each tuple is (name, token) where name is the string name of the token, and token is the substring in the given </span>
<span class="sd">        string corresponding to that token. Extra &#39;newline&#39; tuples will be added inbetween each string.</span>

<span class="sd">        Initially cleans the string. See :func:`~bincfg.normalization.norm_utils.clean_incoming_instruction` for more details.</span>

<span class="sd">        Also pulls prefixes out of opcodes. See top of file for possible placements of instruction prefixes. These prefixes</span>
<span class="sd">        are returned in order before the opcode, with no extra newlines or anything.</span>

<span class="sd">        Args:</span>
<span class="sd">            strings (str): arbitrary number of strings to tokenize.</span>
<span class="sd">            enforce_asm_rules (Optional[bool]): if True, then extra processing and checks will be done to make sure the </span>
<span class="sd">                tokenized assembly language matches the rules of assembly. See self.check_assembly_rules() for more info. </span>
<span class="sd">                If False, these checks aren&#39;t done and bad assembly could make its way through without error, but should </span>
<span class="sd">                be noticeably faster. If None, will use the default value. The default value starts as False at the</span>
<span class="sd">                beginning of program execution but can be modified using </span>
<span class="sd">                :func:`~bincfg.normalization.base_tokenizer._set_default_enforce_asm_rules`</span>
<span class="sd">            newline_tup (Tuple[str, str], optional): the tuple to insert inbetween each passed string, or None to not </span>
<span class="sd">                insert anything. Defaults to `self.__class__.DEFAULT_NEWLINE_TUPLE`.</span>
<span class="sd">            match_instruction_address (bool, optional): if True, will assume there will be an instruction address at the </span>
<span class="sd">                start of the string. This only has an effect on ghidra-like instruction addresses where that address </span>
<span class="sd">                could be interpreted as either an immediate, or an instruction address. If True, then any immediates </span>
<span class="sd">                found at the start of a line will be assumed to be instruction addresses instead of immediates. If False,</span>
<span class="sd">                then instruction addresses can still be matched, but they must end with a colon &#39;:&#39;, otherwise they will </span>
<span class="sd">                be considered immediates. Defaults to True.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TokenMismatchError: on a bad branch prediction string</span>

<span class="sd">        Yields:</span>
<span class="sd">            Tuple[str, str]: (token_name, token) tuples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="o">*</span><span class="n">strings</span><span class="p">,</span> <span class="n">enforce_asm_rules</span><span class="o">=</span><span class="n">enforce_asm_rules</span><span class="p">,</span> <span class="n">newline_tup</span><span class="o">=</span><span class="n">newline_tup</span><span class="p">,</span> 
                             <span class="n">match_instruction_address</span><span class="o">=</span><span class="n">match_instruction_address</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks equality between this tokenizer and another. </span>
<span class="sd">        </span>
<span class="sd">        Defaults to checking if class types are the same and tokens are all equal and in same order. Children should </span>
<span class="sd">            also include other kwargs, etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">((</span><span class="n">n1</span> <span class="o">==</span> <span class="n">n2</span> <span class="ow">and</span> <span class="n">t1</span> <span class="o">==</span> <span class="n">t2</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">t1</span><span class="p">),</span> <span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">tokens</span><span class="p">)))</span>
    
<div class="viewcode-block" id="BaseTokenizer.on_token_mismatch"><a class="viewcode-back" href="../../../bincfg.normalization.html#bincfg.normalization.base_tokenizer.BaseTokenizer.on_token_mismatch">[docs]</a>    <span class="k">def</span> <span class="nf">on_token_mismatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">token</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">mo</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;What to do when there is a token mismatch in a string. Raises a ``TokenMismatchError`` with info on the mismatch</span>

<span class="sd">        Args:</span>
<span class="sd">            token (str): the token that is mismatched</span>
<span class="sd">            string (str): the string in which the mismatch occurred</span>
<span class="sd">            mo (Match): the re match object</span>

<span class="sd">        Raises:</span>
<span class="sd">            TokenMismatchError: by default</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">err_start</span> <span class="o">=</span> <span class="s2">&quot;Mismatched token &#39;</span><span class="si">%s</span><span class="s2">&#39; at index </span><span class="si">%d</span><span class="s2"> in string: </span><span class="se">\&quot;</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">mo</span><span class="o">.</span><span class="n">start</span><span class="p">())</span>
        <span class="k">raise</span> <span class="n">TokenMismatchError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s%s</span><span class="se">\&quot;\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">err_start</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span> <span class="o">*</span> <span class="p">(</span><span class="n">mo</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">err_start</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">TokenMismatchError</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;^&#39;</span><span class="p">))</span></div>
    
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;()&quot;</span>
    
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
    
    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;For some reason, sufficiently complex regex patterns cannot be deepcopied (Perhaps only a python 3.6 problem?).</span>
<span class="sd">        Instead, get the string pattern itself and copy that, then re-compile in __setstate__</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ret</span><span class="p">[</span><span class="s1">&#39;tokenizer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span><span class="o">.</span><span class="n">pattern</span>
        <span class="k">return</span> <span class="n">ret</span>
    
    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;tokenizer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s1">&#39;tokenizer&#39;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span></div>


<span class="c1"># A default tokenizer class</span>
<span class="n">DEFAULT_TOKENIZER</span> <span class="o">=</span> <span class="n">BaseTokenizer</span><span class="p">()</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Justin Allen.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>