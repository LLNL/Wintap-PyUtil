<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>bincfg.utils.misc_utils &mdash; BinCFG 0.1.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> BinCFG
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../bincfg.cfg.html">bincfg.cfg package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bincfg.utils.html">bincfg.utils package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bincfg.normalization.html">bincfg.normalization package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bincfg.labeling.html">bincfg.labeling package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">BinCFG</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">bincfg.utils.misc_utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for bincfg.utils.misc_utils</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Miscellaneous utility functions</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>
<span class="kn">from</span> <span class="nn">hashlib</span> <span class="kn">import</span> <span class="n">sha256</span>


<span class="c1"># The actual progressbar object, once it has been determined</span>
<span class="n">_IMPORT_PROGRESSBAR</span> <span class="o">=</span> <span class="kc">None</span>

<span class="c1"># A logger to log with if needed</span>
<span class="n">LOGGER</span> <span class="o">=</span> <span class="kc">None</span>


<div class="viewcode-block" id="log"><a class="viewcode-back" href="../../../bincfg.utils.html#bincfg.utils.misc_utils.log">[docs]</a><span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="n">severity</span><span class="o">=</span><span class="s1">&#39;info&#39;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Attempts to log a message if LOGGER has already been set&quot;&quot;&quot;</span>
    <span class="n">severity</span> <span class="o">=</span> <span class="n">severity</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">LOGGER</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">elif</span> <span class="n">severity</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;warn&#39;</span><span class="p">,</span> <span class="s1">&#39;warning&#39;</span><span class="p">,</span> <span class="s1">&#39;warns&#39;</span><span class="p">,</span> <span class="s1">&#39;warnings&#39;</span><span class="p">]:</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">severity</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;debug&#39;</span><span class="p">]:</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">severity</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">]:</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">severity</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;critical&#39;</span><span class="p">,</span> <span class="s1">&#39;crit&#39;</span><span class="p">]:</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">severity</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="s1">&#39;err&#39;</span><span class="p">]:</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown severity: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">severity</span><span class="p">))</span></div>


<div class="viewcode-block" id="set_logger"><a class="viewcode-back" href="../../../bincfg.utils.html#bincfg.utils.misc_utils.set_logger">[docs]</a><span class="k">def</span> <span class="nf">set_logger</span><span class="p">(</span><span class="n">logger</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sets the logger for this module&quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">LOGGER</span>
    <span class="n">LOGGER</span> <span class="o">=</span> <span class="n">logger</span></div>


<div class="viewcode-block" id="get_smallest_np_dtype"><a class="viewcode-back" href="../../../bincfg.utils.html#bincfg.utils.misc_utils.get_smallest_np_dtype">[docs]</a><span class="k">def</span> <span class="nf">get_smallest_np_dtype</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">signed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the smallest numpy integer dtype needed to store the given max value.</span>

<span class="sd">    Args:</span>
<span class="sd">        val (int): the largest magnitude (furthest from 0) integer value that we need to be able to store</span>
<span class="sd">        signed (bool, optional): if True, then use signed ints. Defaults to False.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: if a bad value was passed, or if the value was too large to store in a known integer size</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.dtype: the smallest integer dtype needed to store the given max value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">val</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">if</span> <span class="n">signed</span> <span class="k">else</span> <span class="n">val</span>
    <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Val must be &gt;0 if using unsigned values: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">val</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">]</span> <span class="k">if</span> <span class="n">signed</span> <span class="k">else</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">signed</span> <span class="ow">or</span> <span class="o">-</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">dtype</span>

    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Could not find an appropriate size for given integer: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">val</span><span class="p">)</span></div>


<div class="viewcode-block" id="scatter_nd_numpy"><a class="viewcode-back" href="../../../bincfg.utils.html#bincfg.utils.misc_utils.scatter_nd_numpy">[docs]</a><span class="k">def</span> <span class="nf">scatter_nd_numpy</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sets the values at `indices` to `values` in numpy array `target`</span>
<span class="sd">    </span>
<span class="sd">    Shamelessly stolen from: https://stackoverflow.com/questions/46065873/how-to-do-scatter-and-gather-operations-in-numpy</span>

<span class="sd">    Args:</span>
<span class="sd">        target (np.ndarray): the target ndarray to modify</span>
<span class="sd">        indices (np.ndarray): n-d array (same ndim as target) of the indices to set values to</span>
<span class="sd">        values (np.ndarray): 1-d array of the values to set</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: the resultant array, modified inplace</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>  <span class="c1"># type: ignore</span>
    <span class="k">return</span> <span class="n">target</span></div>


<div class="viewcode-block" id="arg_array_split"><a class="viewcode-back" href="../../../bincfg.utils.html#bincfg.utils.misc_utils.arg_array_split">[docs]</a><span class="k">def</span> <span class="nf">arg_array_split</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">sections</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Like np.array_split(), but returns the indices that one would split at</span>

<span class="sd">    This will always return `sections` sections, even if `sections` &gt; length (in which case, any empty sections will</span>
<span class="sd">    come at the end). If `sections` does not perfectly divide `length`, then any extras will be front-loaded, one per</span>
<span class="sd">    split array as needed.</span>

<span class="sd">    NOTE: this code was modified from the numpy array_split() source</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        length (int): the length of the sequence to split</span>
<span class="sd">        sections (int): the number of sections to split into</span>
<span class="sd">        return_index (Optional[int]): if not None, then an int to determine which tuple of (start, end) indices to</span>
<span class="sd">            return (IE: if you were splitting an array into 10 sections, and passed return_index=3, this would return</span>
<span class="sd">            the tuple of (start, end) indicies for the 4th split array (since we start indexing at 0))</span>
<span class="sd">        dtype (np.dtype): the numpy dtype to use for the returned array</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        Union[np.ndarray, Tuple[int, int]]: a numpy array of length `sections + 1` where the split array at index `i`</span>
<span class="sd">            would use the start/end endices `[returned_array[i]:returned_array[i+1]]`, unless return_index is not None,</span>
<span class="sd">            in which case a 2-tuple of the (start_idx, end_idx) will be returned</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">sections</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Number of sections must be &gt; 0. Got </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">sections</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">length</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Length must be &gt;= 0. Got </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">length</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">return_index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">return_index</span> <span class="o">&gt;=</span> <span class="n">sections</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;return_index, if not None, must be a positive integer in the range [0, sections). Got &quot;</span>
            <span class="s2">&quot;sections=</span><span class="si">%d</span><span class="s2">, return_index=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sections</span><span class="p">,</span> <span class="n">return_index</span><span class="p">))</span>

    <span class="c1"># If sections &gt; length, then we would return the array [0, 1, 2, 3, ..., length - 1, length, length, length, ...]</span>
    <span class="c1"># NOTE: this also handles the case where length == 0 since sections &gt; 0 always</span>
    <span class="k">if</span> <span class="n">sections</span> <span class="o">&gt;=</span> <span class="n">length</span><span class="p">:</span>
        <span class="n">ret_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">sections</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">ret_arr</span><span class="p">[</span><span class="n">length</span><span class="p">:]</span> <span class="o">=</span> <span class="n">length</span>

    <span class="c1"># Otherwise we can do the normal divmod method</span>
    <span class="c1"># NOTE: this also handles the case where length == sections</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">num_per_section</span><span class="p">,</span> <span class="n">extras</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">sections</span><span class="p">)</span>
        <span class="n">section_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">extras</span> <span class="o">*</span> <span class="p">[</span><span class="n">num_per_section</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">sections</span> <span class="o">-</span> <span class="n">extras</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="n">num_per_section</span><span class="p">]</span>
        <span class="n">ret_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">section_sizes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">return_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ret_arr</span><span class="p">[</span><span class="n">return_index</span><span class="p">],</span> <span class="n">ret_arr</span><span class="p">[</span><span class="n">return_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">ret_arr</span></div>


<span class="c1"># Some object types</span>
<span class="n">_SingletonObjects</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="bp">Ellipsis</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">]</span>
<span class="n">_DictKeysType</span> <span class="o">=</span> <span class="nb">type</span><span class="p">({}</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="n">_GeneratorType</span> <span class="o">=</span> <span class="nb">type</span><span class="p">((</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

<span class="n">_MAX_STR_LEN</span> <span class="o">=</span> <span class="mi">1000</span>

<span class="c1"># Types that are all able to be checked against one another using default &#39;==&#39; equality check</span>
<span class="n">_DUNDER_EQ_TYPES</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="nb">complex</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">,</span> <span class="nb">bytearray</span><span class="p">,</span> <span class="nb">memoryview</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="nb">set</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">,</span> <span class="n">_DictKeysType</span><span class="p">)</span>

<span class="c1"># Keep track of the current kwargs being used in equal()</span>
<span class="n">_CURR_EQUAL_KWARGS</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">_EQ_DEFAULT_STRICT_TYPES</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
<span class="n">_EQ_DEFAULT_UNORDERED</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
<span class="n">_EQ_DEFAULT_RAISE_ERR</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>


<span class="c1"># Context manager to return _CURR_EQUAL_KWARGS back to expected</span>
<span class="k">class</span> <span class="nc">_ReturnCurrEqualKwargs</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>
    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">global</span> <span class="n">_CURR_EQUAL_KWARGS</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;control_kwargs&#39;</span><span class="p">]:</span>
            <span class="n">_CURR_EQUAL_KWARGS</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;prev_&#39;</span><span class="p">):</span>
                    <span class="n">_CURR_EQUAL_KWARGS</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="s1">&#39;prev_&#39;</span><span class="p">):]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>


<div class="viewcode-block" id="eq_obj"><a class="viewcode-back" href="../../../bincfg.utils.html#bincfg.utils.misc_utils.eq_obj">[docs]</a><span class="k">def</span> <span class="nf">eq_obj</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">selector</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict_types</span><span class="o">=</span><span class="n">_EQ_DEFAULT_STRICT_TYPES</span><span class="p">,</span> <span class="n">unordered</span><span class="o">=</span><span class="n">_EQ_DEFAULT_UNORDERED</span><span class="p">,</span> <span class="n">raise_err</span><span class="o">=</span><span class="n">_EQ_DEFAULT_RAISE_ERR</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines whether a == b, generalizing for more objects and capabilities than default __eq__() method.</span>
<span class="sd">    Equal() is an equivalence relation, and thus:</span>
<span class="sd">    </span>
<span class="sd">        1. equal(a, a) is always True                       (reflexivity)</span>
<span class="sd">        2. equal(a, b) implies equal(b, a)                  (symmetry)</span>
<span class="sd">        3. equal(a, b) and equal(b, c) implies equal(a, c)  (transitivity)</span>
<span class="sd">    </span>
<span class="sd">    NOTE: This method is not meant to be very fast. I will apply as many optimizations as feasibly possible that I can</span>
<span class="sd">    think of, but there will be various inefficient conversions of types to check equality.</span>
<span class="sd">    </span>
<span class="sd">    NOTE: kwargs passed to the initial :func:`~gstats_utils.pythonutils.equality.equal` function call will be passed to </span>
<span class="sd">    all subcalls, including those done in other objects using their built-in __eq__ function. Any objects can override</span>
<span class="sd">    those kwargs for any later subcalls (but not those above/adjacent). </span>
<span class="sd">    NOTE: The `selector` kwarg is only used once, then consumed for any later subcalls</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        a (Any): object to check equality</span>
<span class="sd">        b (Any): object to check equality</span>
<span class="sd">        selector (Optional[str]): if not None, then a string that determines the &#39;selector&#39; to use on both objects for</span>
<span class="sd">            determining equality. It should start with either a letter (case-sensitive), underscore &#39;_&#39;, dot &#39;.&#39; or</span>
<span class="sd">            bracket &#39;[&#39;. This string will essentially be appended to each object to get some attribute to determine</span>
<span class="sd">            equality of instead of the objects themselves. For example, if you have two lists, but only want to check</span>
<span class="sd">            if their element at index &#39;2&#39; are equal, you could pass `selector=&#39;[2]&#39;`. This is useful for debugging purposes</span>
<span class="sd">            as the error messages on unequal objects will be far more informative. Defaults to None.</span>
<span class="sd">            NOTE: if you pass a `selector` string that starts with an alphabetical character, it will be assumed to be</span>
<span class="sd">            an attribute, and this will check equality on `a.SELECTOR` and `b.SELECTOR`</span>
<span class="sd">        strict_types (bool): if True, then the types of both objects must exactly match. Otherwise objects which are </span>
<span class="sd">            equal but of different types will be considered equal. Defaults to False.</span>
<span class="sd">        unordered (bool): if True, then all known sequential objects (list, tuple, numpy array, etc.) will be considered</span>
<span class="sd">            equal even if elements are in a different order (eg: a multiset equality). Otherwise, sequential objects are</span>
<span class="sd">            expected to have their subelements appear in the same order. If the passed objects are not sequential, then</span>
<span class="sd">            this has no effect. Defaults to False.</span>
<span class="sd">        raise_err (bool): if True, then an ``EqualityError`` will be raised whenever `a` and `b` are unequal, along with</span>
<span class="sd">            an informative stack trace as to why they were determined to be unequal. Defaults to False.</span>
<span class="sd">    </span>
<span class="sd">    Raises:</span>
<span class="sd">        EqualityError: if the two objects are not equal, and `raise_err=True`</span>
<span class="sd">        EqualityCheckingError: if there was an error raised during equality checking</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        bool: True if the two objects are equal, False otherwise</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if we are the first call and thus should controll the kwargs</span>
    <span class="k">global</span> <span class="n">_CURR_EQUAL_KWARGS</span>
    <span class="n">_stack_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;control_kwargs&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">_CURR_EQUAL_KWARGS</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_stack_kwargs</span><span class="p">[</span><span class="s1">&#39;control_kwargs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">_CURR_EQUAL_KWARGS</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;strict_types&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;unordered&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;raise_err&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>
    
    <span class="c1"># Update the kwargs if needed, otherwise grab them from the curr kwargs</span>
    <span class="n">_stack_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;prev_strict_types&#39;</span><span class="p">:</span> <span class="n">_CURR_EQUAL_KWARGS</span><span class="p">[</span><span class="s1">&#39;strict_types&#39;</span><span class="p">],</span> <span class="s1">&#39;prev_unordered&#39;</span><span class="p">:</span> <span class="n">_CURR_EQUAL_KWARGS</span><span class="p">[</span><span class="s1">&#39;unordered&#39;</span><span class="p">],</span>
        <span class="s1">&#39;prev_raise_err&#39;</span><span class="p">:</span> <span class="n">_CURR_EQUAL_KWARGS</span><span class="p">[</span><span class="s1">&#39;raise_err&#39;</span><span class="p">]})</span>
    <span class="k">if</span> <span class="n">strict_types</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_EQ_DEFAULT_STRICT_TYPES</span><span class="p">:</span>
        <span class="n">_CURR_EQUAL_KWARGS</span><span class="p">[</span><span class="s1">&#39;strict_types&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">strict_types</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">strict_types</span> <span class="o">=</span> <span class="n">_CURR_EQUAL_KWARGS</span><span class="p">[</span><span class="s1">&#39;strict_types&#39;</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">unordered</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_EQ_DEFAULT_UNORDERED</span><span class="p">:</span>
        <span class="n">_CURR_EQUAL_KWARGS</span><span class="p">[</span><span class="s1">&#39;unordered&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unordered</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">unordered</span> <span class="o">=</span> <span class="n">_CURR_EQUAL_KWARGS</span><span class="p">[</span><span class="s1">&#39;unordered&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">raise_err</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_EQ_DEFAULT_RAISE_ERR</span><span class="p">:</span>
        <span class="n">_CURR_EQUAL_KWARGS</span><span class="p">[</span><span class="s1">&#39;raise_err&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">raise_err</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">raise_err</span> <span class="o">=</span> <span class="n">_CURR_EQUAL_KWARGS</span><span class="p">[</span><span class="s1">&#39;raise_err&#39;</span><span class="p">]</span>

    <span class="c1"># Cover with a context manager to reset _CURR_EQUAL_KWARGS back to expected values</span>
    <span class="k">with</span> <span class="n">_ReturnCurrEqualKwargs</span><span class="p">(</span><span class="n">_stack_kwargs</span><span class="p">):</span>
        
        <span class="c1"># Get the right selector, raising an error if it&#39;s bad</span>
        <span class="k">if</span> <span class="n">selector</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">selector</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`selector` arg must be str, not </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">selector</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">selector</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="n">selector</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="n">selector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isalpha</span><span class="p">():</span>
                <span class="n">selector</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">selector</span>
            <span class="k">elif</span> <span class="n">selector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s1">&#39;._[&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`selector` string must start with a &#39;.&#39;, &#39;_&#39;, &#39;[&#39;, or alphabetic character: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">selector</span><span class="p">))</span>
        
        <span class="c1"># Use `selector` if needed</span>
        <span class="k">if</span> <span class="n">selector</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_failed_obj_name</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span>
                <span class="n">_check_a</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;a&#39;</span> <span class="o">+</span> <span class="n">selector</span><span class="p">)</span>
                <span class="n">_failed_obj_name</span> <span class="o">=</span> <span class="s1">&#39;b&#39;</span>
                <span class="n">_check_b</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;b&#39;</span> <span class="o">+</span> <span class="n">selector</span><span class="p">)</span>
                <span class="n">_failed_obj_name</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="k">return</span> <span class="n">eq_obj</span><span class="p">(</span><span class="n">_check_a</span><span class="p">,</span> <span class="n">_check_b</span><span class="p">,</span> <span class="n">selector</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict_types</span><span class="o">=</span><span class="n">strict_types</span><span class="p">,</span> <span class="n">unordered</span><span class="o">=</span><span class="n">unordered</span><span class="p">,</span> <span class="n">raise_err</span><span class="o">=</span><span class="n">raise_err</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">EqualityError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">EqualityError</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="s2">&quot;Objects had different sub-objects using `selector` </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">selector</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">_failed_obj_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">EqualityCheckingError</span><span class="p">(</span><span class="s2">&quot;Could not determine equality between objects a and b using `selector` </span><span class="si">%s</span><span class="se">\n</span><span class="s2">a: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">b: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                        <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">selector</span><span class="p">),</span> <span class="n">_limit_str</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">_limit_str</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>
                <span class="k">raise</span> <span class="n">EqualityCheckingError</span><span class="p">(</span><span class="s2">&quot;Could not use `selector` with value </span><span class="si">%s</span><span class="s2"> on object `</span><span class="si">%s</span><span class="s2">`&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">selector</span><span class="p">),</span> <span class="n">_failed_obj_name</span><span class="p">))</span>

        <span class="c1"># Wrap everything in a try/catch in case there is an error, so it will be easier to spot</span>
        <span class="k">try</span><span class="p">:</span>

            <span class="c1"># Do a quick first check for &#39;is&#39; as they should always be equal, no matter what</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="n">b</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            
            <span class="c1"># Check if there are strict types</span>
            <span class="k">if</span> <span class="n">strict_types</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">_eq_check</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">raise_err</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s1">&#39;Objects are of different types and `strict_types=True`.&#39;</span><span class="p">)</span>
            
            <span class="c1">##################</span>
            <span class="c1"># Checking types #</span>
            <span class="c1">##################</span>

            <span class="c1"># We already checked &#39;is&#39;, so this must be an error</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">a</span> <span class="ow">is</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">_SingletonObjects</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Enum</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">_eq_check</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">raise_err</span><span class="p">)</span>
            
            <span class="c1"># Check for bool first that way int&#39;s and bool&#39;s cannot be equal</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="c1"># Enforce that this is a bool no matter what. Bool&#39;s are NOT int&#39;s. I will die on this hill...</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">_eq_enforce_types</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">raise_err</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">return</span> <span class="n">_eq_check</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">raise_err</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            
            <span class="c1"># Check for objects using &#39;==&#39;</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">_DUNDER_EQ_TYPES</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">_eq_enforce_types</span><span class="p">(</span><span class="n">_DUNDER_EQ_TYPES</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">raise_err</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">return</span> <span class="n">_eq_check</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">raise_err</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            
            <span class="c1"># Check for sequences list/tuple</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                
                <span class="c1"># Check that b is something that could be converted into a list/tuple nicely</span>

                <span class="c1"># If check_b is a numpy array, convert check_a to one and do a numpy comparison</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="c1"># Check if check_b is an object array, and if so, use lists, otherwise use numpy</span>
                    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">object</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">_check_with_conversion</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">unordered</span><span class="p">,</span> <span class="n">raise_err</span><span class="p">,</span> <span class="n">strict_types</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">_check_with_conversion</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">unordered</span><span class="p">,</span> <span class="n">raise_err</span><span class="p">)</span>

                <span class="c1"># Check for things to convert to list</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="n">_GeneratorType</span><span class="p">,</span> <span class="n">_DictKeysType</span><span class="p">)):</span>
                    <span class="k">return</span> <span class="n">_check_with_conversion</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">unordered</span><span class="p">,</span> <span class="n">raise_err</span><span class="p">)</span>
                
                <span class="c1"># Otherwise, make sure check_b is a list/tuple</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                    <span class="k">return</span> <span class="n">_eq_check</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">raise_err</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;checked b type could not be converted into list/tuple&quot;</span><span class="p">)</span>
                
                <span class="c1"># This is where we handle the actual checking.</span>
                <span class="c1"># Check that they are the same length</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">_eq_check</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">raise_err</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Objects had different lengths: </span><span class="si">%d</span><span class="s2"> != </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>
                
                <span class="c1"># If we are using ordered, then we can just naively check, otherwise, we have to do some other things...</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">unordered</span><span class="p">:</span>
                    <span class="c1"># Check each element in the lists</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">_checking_a</span><span class="p">,</span> <span class="n">_checking_b</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)):</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="c1"># It will have returned an error if raise_err, so just return False</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">eq_obj</span><span class="p">(</span><span class="n">_checking_a</span><span class="p">,</span> <span class="n">_checking_b</span><span class="p">,</span> <span class="n">selector</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict_types</span><span class="o">=</span><span class="n">strict_types</span><span class="p">,</span> <span class="n">unordered</span><span class="o">=</span><span class="n">unordered</span><span class="p">,</span> <span class="n">raise_err</span><span class="o">=</span><span class="n">raise_err</span><span class="p">):</span>
                                <span class="k">return</span> <span class="kc">False</span>
                        <span class="k">except</span> <span class="n">EqualityError</span><span class="p">:</span>  <span class="c1"># If we get an equality error, then raise_err must be true</span>
                            <span class="k">raise</span> <span class="n">EqualityError</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="s2">&quot;Values at index </span><span class="si">%d</span><span class="s2"> were not equal&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">EqualityCheckingError</span><span class="p">(</span><span class="s2">&quot;Could not determine equality between elements at index </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
                    
                    <span class="c1"># Now we can return True</span>
                    <span class="k">return</span> <span class="kc">True</span>

                <span class="c1"># Unordered list checking</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
            
            <span class="c1"># Check for numpy array</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>

                <span class="c1"># Ensure the other value can be converted into an array</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="c1"># If check_a is an object array, then just convert it to a list now and have that check it</span>
                    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">object</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">_check_with_conversion</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">unordered</span><span class="p">,</span> <span class="n">raise_err</span><span class="p">,</span> <span class="n">strict_types</span><span class="p">)</span>
                    
                    <span class="c1"># Otherwise, if it is a known convertible, convert it</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">_GeneratorType</span><span class="p">)):</span>
                        <span class="k">return</span> <span class="n">_check_with_conversion</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">unordered</span><span class="p">,</span> <span class="n">raise_err</span><span class="p">,</span> <span class="n">strict_types</span><span class="p">)</span>
                    
                    <span class="c1"># Otherwise, assume not equal</span>
                    <span class="k">return</span> <span class="n">_eq_check</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">raise_err</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Could not convert b object of type </span><span class="si">%s</span><span class="s2"> to numpy array&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

                <span class="c1"># Check if we are using objects or a different dtype</span>
                <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">object</span><span class="p">:</span>
                    <span class="c1"># Attempt to check using lists at this point</span>
                    <span class="k">return</span> <span class="n">_check_with_conversion</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">unordered</span><span class="p">,</span> <span class="n">raise_err</span><span class="p">,</span> <span class="n">strict_types</span><span class="p">)</span>

                <span class="c1"># Otherwise, check if we are doing unordered or ordered.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">unordered</span><span class="p">:</span>
                    <span class="c1"># we can use the builtin numpy assert equal thing</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_equal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
                        <span class="k">return</span> <span class="kc">True</span>
                    <span class="k">except</span> <span class="ne">AssertionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">_eq_check</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">raise_err</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s1">&#39;Numpy assert_equal found discrepancies:</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span>
                
                <span class="c1"># Otherwise we need to do an unordered equality check. Just convert to a list at this point and check it</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">_check_with_conversion</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">unordered</span><span class="p">,</span> <span class="n">raise_err</span><span class="p">,</span> <span class="n">strict_types</span><span class="p">)</span>
            
            <span class="c1"># Check for dictionaries</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="c1"># b must be a dictionary</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">_eq_enforce_types</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">raise_err</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s1">&#39;Dictionaries must be same type to compare&#39;</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>
                
                <span class="c1"># Check all the keys are the same</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">eq_obj</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">selector</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict_types</span><span class="o">=</span><span class="n">strict_types</span><span class="p">,</span> <span class="n">unordered</span><span class="o">=</span><span class="n">unordered</span><span class="p">,</span> <span class="n">raise_err</span><span class="o">=</span><span class="n">raise_err</span><span class="p">):</span>
                        <span class="k">return</span> <span class="kc">False</span>
                <span class="k">except</span> <span class="n">EqualityError</span><span class="p">:</span>  <span class="c1"># If we get an equality error, then raise_err must be true</span>
                    <span class="n">a_un</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">a</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">b</span><span class="p">)</span>
                    <span class="n">b_un</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">b</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">a</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="n">EqualityError</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Dictionaries had different .keys()</span><span class="se">\n</span><span class="s2">`a`-unique keys: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">`b`-unique keys: </span><span class="si">%s</span><span class="s2">&quot;</span> 
                                        <span class="o">%</span> <span class="p">(</span><span class="n">_limit_str</span><span class="p">(</span><span class="n">a_un</span><span class="p">),</span> <span class="n">_limit_str</span><span class="p">(</span><span class="n">b_un</span><span class="p">)))</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">EqualityCheckingError</span><span class="p">(</span><span class="s2">&quot;Could not determine equality between dictionary keys</span><span class="se">\n</span><span class="s2">a: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">b: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                        <span class="p">(</span><span class="n">_limit_str</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="n">_limit_str</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
                
                <span class="c1"># Check all the values are the same</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">eq_obj</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">selector</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict_types</span><span class="o">=</span><span class="n">strict_types</span><span class="p">,</span> <span class="n">unordered</span><span class="o">=</span><span class="n">unordered</span><span class="p">,</span> <span class="n">raise_err</span><span class="o">=</span><span class="n">raise_err</span><span class="p">):</span>
                            <span class="k">return</span> <span class="kc">False</span>
                    <span class="k">except</span> <span class="n">EqualityError</span><span class="p">:</span>  <span class="c1"># If we get an equality error, then raise_err must be true</span>
                        <span class="k">raise</span> <span class="n">EqualityError</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Values at key </span><span class="si">%s</span><span class="s2"> differ&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">EqualityCheckingError</span><span class="p">(</span><span class="s2">&quot;Could not determine equality between dictionary values at key </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                
                <span class="c1"># Now we can return True</span>
                <span class="k">return</span> <span class="kc">True</span>
            
            <span class="c1"># Otherwise, use the default equality measure</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">_eq_check</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">raise_err</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s1">&#39;Using built-in __eq__ equality measure&#39;</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">EqualityError</span><span class="p">:</span>  <span class="c1"># If we get an equality error, then raise_err must be true</span>
                    <span class="k">raise</span> <span class="n">EqualityError</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Values were not equal using built-in __eq__ method&quot;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">EqualityCheckingError</span><span class="p">(</span><span class="s2">&quot;Could not determine equality between dictionary values using built-in __eq__ method&quot;</span><span class="p">)</span>
        
        <span class="k">except</span> <span class="n">EqualityError</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">EqualityCheckingError</span><span class="p">(</span><span class="s2">&quot;Could not determine equality between objects</span><span class="se">\n</span><span class="s2">a: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">b: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">_limit_str</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">_limit_str</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span></div>


<span class="k">def</span> <span class="nf">_check_with_conversion</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">type_a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">type_b</span><span class="p">,</span> <span class="n">unordered</span><span class="p">,</span> <span class="n">raise_err</span><span class="p">,</span> <span class="n">strict_types</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Attempts to convert check_a into type_a and check_b into type_b (by calling the types), then check equality on those</span>
<span class="sd">    </span>
<span class="sd">    Gives better error messages when things go wrong. You can pass None to one of the types to not change type. Pass the</span>
<span class="sd">    type itself (instead of a function) for better nameing on error messages about what they were being converted into.</span>
<span class="sd">    The name is given by type_a.__name__ if type_a is a type, or &#39;a lambda function&#39; if it is an annonymus function, or</span>
<span class="sd">    the module + function name if a function</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ca_type</span><span class="p">,</span> <span class="n">check_a_str</span> <span class="o">=</span> <span class="n">_get_check_type</span><span class="p">(</span><span class="n">type_a</span><span class="p">)</span>
    <span class="n">cb_type</span><span class="p">,</span> <span class="n">check_b_str</span> <span class="o">=</span> <span class="n">_get_check_type</span><span class="p">(</span><span class="n">type_b</span><span class="p">)</span>

    <span class="n">conversion_str</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;(with a value being converted using </span><span class="si">%s</span><span class="s1"> and b value being converted using </span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">check_a_str</span><span class="p">,</span> <span class="n">check_b_str</span><span class="p">))</span>\
            <span class="k">if</span> <span class="n">check_a_str</span> <span class="ow">and</span> <span class="n">check_b_str</span> <span class="k">else</span> \
        <span class="p">(</span><span class="s1">&#39;(with a value being converted using </span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">check_a_str</span><span class="p">)</span> <span class="k">if</span> <span class="n">check_a_str</span> <span class="k">else</span> \
        <span class="p">(</span><span class="s1">&#39;(with b value being converted using </span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">check_b_str</span><span class="p">)</span> <span class="k">if</span> <span class="n">check_b_str</span> <span class="k">else</span> \
        <span class="s1">&#39;&#39;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">eq_obj</span><span class="p">(</span><span class="n">ca_type</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">cb_type</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">selector</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict_types</span><span class="o">=</span><span class="n">strict_types</span><span class="p">,</span> <span class="n">unordered</span><span class="o">=</span><span class="n">unordered</span><span class="p">,</span> <span class="n">raise_err</span><span class="o">=</span><span class="n">raise_err</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">EqualityCheckingError</span><span class="p">:</span>
        <span class="k">raise</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="n">_eq_check</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">raise_err</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Values were not equal </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">conversion_str</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_check_type</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a function to call and a string describing what is being used to convert type given the type to convert</span>
<span class="sd">    </span>
<span class="sd">    Returns a tuple of (conversion_callable, type_description_string). The string will be empty if the conversion is</span>
<span class="sd">    the identity, t.__name__ if t is a type, &#39;a lambda function&#39; if it is an anonymous function, or the module + </span>
<span class="sd">    function/class name if it is a callable.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;&#39;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">EqualityCheckingError</span><span class="p">(</span><span class="s2">&quot;Cannot convert object types as given `type` is not callable: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;type &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="k">else</span> <span class="nb">repr</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_eq_enforce_types</span><span class="p">(</span><span class="n">types</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">raise_err</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;enforces check_b is of the given types using isinstance&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">types</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">types</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_eq_check</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">raise_err</span><span class="p">,</span> <span class="s1">&#39;Objects were of incompatible types. </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">message</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">_eq_check</span><span class="p">(</span><span class="n">checked</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">raise_err</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;bool equal check, determine whether or not we need to raise an error with info, or just return true/false&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">checked</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">raise_err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">EqualityError</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">class</span> <span class="nc">_TimeoutFuncThread</span><span class="p">(</span><span class="n">Thread</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A simple Thread class to call the passed function with passed args/kwargs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param func: the function to call</span>
<span class="sd">        :param args: *args to pass to function when calling</span>
<span class="sd">        :param kwargs: **kwargs to pass to function when calling</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span> <span class="o">=</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_return</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This should never be called. Instead, call TimeoutFuncThread.start() to start thread</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_return</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_func</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="p">)</span>


<div class="viewcode-block" id="timeout_wrapper"><a class="viewcode-back" href="../../../bincfg.utils.html#bincfg.utils.misc_utils.timeout_wrapper">[docs]</a><span class="k">def</span> <span class="nf">timeout_wrapper</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">timeout_ret_val</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wraps a function to allow for timing-out after the specified time. If the function has not completed after timeout</span>
<span class="sd">        seconds, then the function will be terminated.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">wraped_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">thread</span> <span class="o">=</span> <span class="n">_TimeoutFuncThread</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

            <span class="n">init_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">sleep_time</span> <span class="o">=</span> <span class="mf">1e-8</span>
            <span class="k">while</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">init_time</span> <span class="o">&lt;</span> <span class="n">timeout</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">thread</span><span class="o">.</span><span class="n">is_alive</span><span class="p">():</span>
                    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">sleep_time</span><span class="p">)</span>
                    <span class="n">sleep_time</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">sleep_time</span> <span class="o">*</span> <span class="mf">1.05</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">thread</span><span class="o">.</span><span class="n">_return</span>
            
            <span class="c1"># If we make it here, there is an error, return value</span>
            <span class="k">return</span> <span class="n">timeout_ret_val</span>
    
        <span class="k">return</span> <span class="n">wraped_func</span>
    <span class="k">return</span> <span class="n">decorator</span></div>


<span class="c1"># Fail if string conversion takes &gt; 10 seconds</span>
<span class="n">_STR_CONV_TIMEOUT_SECONDS</span> <span class="o">=</span> <span class="mi">10</span>

<span class="nd">@timeout_wrapper</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="n">_STR_CONV_TIMEOUT_SECONDS</span><span class="p">,</span> <span class="n">timeout_ret_val</span><span class="o">=</span><span class="s2">&quot;[ERROR: String conversion timed out. Max time: </span><span class="si">%d</span><span class="s2"> seconds]&quot;</span> <span class="o">%</span> <span class="n">_STR_CONV_TIMEOUT_SECONDS</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_limit_str</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">_MAX_STR_LEN</span><span class="p">):</span>
    <span class="n">a_str</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a_str</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_str</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">limit</span> <span class="k">else</span> <span class="p">(</span><span class="n">a_str</span><span class="p">[:</span><span class="n">limit</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;...&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="EqualityError"><a class="viewcode-back" href="../../../bincfg.utils.html#bincfg.utils.misc_utils.EqualityError">[docs]</a><span class="k">class</span> <span class="nc">EqualityError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Error raised whenever an :func:`~gstats_utils.pythonutils.equality.equal` check returns false and `raise_err=True`&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Values are not equal&quot;</span> <span class="k">if</span> <span class="n">message</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">message</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;Object a (</span><span class="si">%s</span><span class="s2">) is not equal to object b (</span><span class="si">%s</span><span class="s2">)</span><span class="se">\n</span><span class="s2">a: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">b: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">Message: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> \
            <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">),</span> <span class="n">_limit_str</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">_limit_str</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">message</span><span class="p">))</span></div>


<div class="viewcode-block" id="EqualityCheckingError"><a class="viewcode-back" href="../../../bincfg.utils.html#bincfg.utils.misc_utils.EqualityCheckingError">[docs]</a><span class="k">class</span> <span class="nc">EqualityCheckingError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Error raised whenever there is an unexpected problem attempting to check equality between two objects&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="eq_obj_err"><a class="viewcode-back" href="../../../bincfg.utils.html#bincfg.utils.misc_utils.eq_obj_err">[docs]</a><span class="k">def</span> <span class="nf">eq_obj_err</span><span class="p">(</span><span class="n">obj1</span><span class="p">,</span> <span class="n">obj2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Same as eq_obj, but always raises an error&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">eq_obj</span><span class="p">(</span><span class="n">obj1</span><span class="p">,</span> <span class="n">obj2</span><span class="p">,</span> <span class="n">raise_err</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="hash_obj"><a class="viewcode-back" href="../../../bincfg.utils.html#bincfg.utils.misc_utils.hash_obj">[docs]</a><span class="k">def</span> <span class="nf">hash_obj</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">return_int</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Hashes the given object</span>

<span class="sd">    Args:</span>
<span class="sd">        obj (Any): the object to hash</span>
<span class="sd">        return_int (bool, optional): by default this method returns a hex string, but setting return_int=True will </span>
<span class="sd">            return an integer instead. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[str, int]: hash of the given object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">string</span> <span class="o">+=</span> <span class="s1">&#39;[None]&#39;</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)):</span>
        <span class="n">string</span> <span class="o">+=</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;) &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
        <span class="n">string</span> <span class="o">+=</span> <span class="s1">&#39;(int) &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">)):</span>
        <span class="n">string</span> <span class="o">+=</span> <span class="s1">&#39;(float) &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">string</span> <span class="o">+=</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;) &#39;</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">:</span>
            <span class="n">string</span> <span class="o">+=</span> <span class="n">hash_obj</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">)):</span>
        <span class="n">string</span> <span class="o">+=</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;) &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">hash_obj</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">return_int</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">string</span> <span class="o">+=</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;) &#39;</span>
        <span class="n">string</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">hash_obj</span><span class="p">(</span><span class="n">hash_obj</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span> <span class="o">+</span> <span class="n">hash_obj</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">return_int</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">string</span> <span class="o">+=</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;) &#39;</span>
        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">object</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">:</span>
                <span class="n">string</span> <span class="o">+=</span> <span class="n">hash_obj</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">string</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">Pattern</span><span class="p">):</span>
        <span class="n">string</span> <span class="o">+=</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;) &#39;</span> <span class="o">+</span> <span class="n">hash_obj</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">pattern</span><span class="p">)</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="n">string</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
    
    <span class="n">hasher</span> <span class="o">=</span> <span class="n">sha256</span><span class="p">()</span>
    <span class="n">hasher</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">hasher</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span> <span class="k">if</span> <span class="n">return_int</span> <span class="k">else</span> <span class="n">hasher</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span></div>


<div class="viewcode-block" id="get_module"><a class="viewcode-back" href="../../../bincfg.utils.html#bincfg.utils.misc_utils.get_module">[docs]</a><span class="k">def</span> <span class="nf">get_module</span><span class="p">(</span><span class="n">package</span><span class="p">,</span> <span class="n">raise_err</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">err_message</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks that the given package is installed, returning it, and raising an error if not</span>

<span class="sd">    Args:</span>
<span class="sd">        package (str): string name of the package</span>
<span class="sd">        raise_err (bool, optional): by default, this will raise an error if attempting to load the module and it doesn&#39;t </span>
<span class="sd">            exist. If False, then None will be returned instead if it doesn&#39;t exist. Defaults to True.</span>
<span class="sd">        err_message (str): an error message to add on to any import errors raised</span>

<span class="sd">    Raises:</span>
<span class="sd">        ImportError: if the package cannot be found, and `raise_err=True`</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[ModuleType, None]: the package</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">importlib</span>
        <span class="k">return</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="n">package</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">raise_err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;Could not find `</span><span class="si">%s</span><span class="s2">` package.</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">package</span><span class="p">,</span> <span class="n">err_message</span><span class="p">))</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="isinstance_with_iterables"><a class="viewcode-back" href="../../../bincfg.utils.html#bincfg.utils.misc_utils.isinstance_with_iterables">[docs]</a><span class="k">def</span> <span class="nf">isinstance_with_iterables</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ret_list</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks that obj is one of the given types, allowing for iterables of these types</span>

<span class="sd">    Args:</span>
<span class="sd">        obj (Any): the obj to test type</span>
<span class="sd">        types (Union[type, Tuple[type, ...]]): either a type, or tuple of types that obj can be</span>
<span class="sd">        recursive (bool, optional): by default, this method will only allow iterables to contain objects of a type in </span>
<span class="sd">            `types`. If `recursive=True`, then this will accept arbitrary-depth iterables of types in `types`. </span>
<span class="sd">            Defaults to False.</span>
<span class="sd">        ret_list (bool, optional): if True, will return a single list of all elements (or None if the isinstance check </span>
<span class="sd">            fails). Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[List[Any], bool, None]: the return value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">types</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">obj</span><span class="p">]</span> <span class="k">if</span> <span class="n">ret_list</span> <span class="k">else</span> <span class="kc">True</span>
    
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ret_list</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="p">[</span><span class="n">elem</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">types</span><span class="p">)</span> <span class="k">else</span> <span class="n">isinstance_with_iterables</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ret_list</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">if</span> <span class="n">recursive</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">ret</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">types</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">recursive</span> <span class="ow">and</span> <span class="n">isinstance_with_iterables</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ret_list</span><span class="o">=</span><span class="kc">False</span><span class="p">))):</span>
                    <span class="k">return</span> <span class="kc">False</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">ret_list</span> <span class="k">else</span> <span class="kc">False</span></div>


<span class="c1"># This fixes a very dumb, stupid, idiotic, and dumb problem that caused me so much hassle for no reason: ipython overrides</span>
<span class="c1">#   the default exception handler in python so that it can print exceptions without them crashing the kernel every time.</span>
<span class="c1">#   That makes sense, however they also take any error strings and change them, converting anything inside &lt;&gt; into their</span>
<span class="c1">#   html (i think?) representation. Even this isn&#39;t so bad, but if you put anything that can&#39;t be parsed correctly inside</span>
<span class="c1">#   those &lt;&gt; tags, it will fail silently and remove the entire tag. Meaning, if you have an error occur while, oh I don&#39;t</span>
<span class="c1">#   know, testing/debugging your tokenizer that handles rose output. It will say the parsing failed on the string:</span>
<span class="c1">#       &quot;0x00402ccc: mov    rax, qword ds:[rip + 0x000000000025230d]&quot;</span>
<span class="c1">#   when it didn&#39;t. And so you spend many hours of your life trying to figure out why it&#39;s not working on that string</span>
<span class="c1">#   when the ~actual~ string it failed on was:</span>
<span class="c1">#       &quot;0x00402ccc: mov    rax, qword ds:[rip + 0x000000000025230d&lt;absolute=0x0000000000654fe0&gt;]&quot;</span>
<span class="c1">#   but the exception handler just ate up that extra rose information in the &lt;&gt; tags and didn&#39;t even have the decency</span>
<span class="c1">#   to mention it.</span>
<span class="c1">#   This overrides the ipython exception handler (if we are using ipython) and replaces all &quot;&lt;&quot; with &quot;&lt;&lt;aa&gt;&quot;. &quot;aa&quot; is</span>
<span class="c1">#   not a known html tag, and so it fails silently eating only the &quot;&lt;aa&gt;&quot; section, while leaving the rest of the original</span>
<span class="c1">#   &lt;&gt; tag intact. This is the best/easiest way I could think of that would keep the normal notebook exception printing</span>
<span class="c1">#   (which I otherwise like), and stop it from destroying my exception messages that I worked so hard on</span>
<span class="c1">#   This seems to work on any weird mashing combination of &#39;&lt;&#39;s and other characters I tested, so it&#39;s good enough for me</span>
<span class="c1">#</span>
<span class="c1"># GREAT, ANOTHER PROBLEM: doing this removes the full stack trace that will happen when one exception is caught but</span>
<span class="c1">#   another is raised (IE: the whole &#39;During handling of the above exception, another exception occurred&#39; thing). I&#39;m</span>
<span class="c1">#   going to have to figure out how to fix this, but for now, I&#39;m gonna turn this off.</span>
<span class="n">_OVERRIDE_EXC_HANDLER</span> <span class="o">=</span> <span class="kc">False</span>
<span class="k">if</span> <span class="n">_OVERRIDE_EXC_HANDLER</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">_custom_exc</span><span class="p">(</span><span class="n">shell</span><span class="p">,</span> <span class="n">etype</span><span class="p">,</span> <span class="n">evalue</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">tb_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">shell</span><span class="o">.</span><span class="n">showtraceback</span><span class="p">((</span><span class="n">etype</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">evalue</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&lt;&#39;</span><span class="p">,</span> <span class="s2">&quot;&lt;&lt;aa&gt;&quot;</span><span class="p">),</span> <span class="n">tb</span><span class="p">),</span> <span class="n">tb_offset</span><span class="o">=</span><span class="n">tb_offset</span><span class="p">)</span>

        <span class="c1"># Done this way to remove a yellow squiggly</span>
        <span class="kn">import</span> <span class="nn">__main__</span>
        <span class="nb">getattr</span><span class="p">(</span><span class="n">__main__</span><span class="p">,</span> <span class="s1">&#39;get_ipython&#39;</span><span class="p">)()</span><span class="o">.</span><span class="n">set_custom_exc</span><span class="p">((</span><span class="ne">Exception</span><span class="p">,</span> <span class="p">),</span> <span class="n">_custom_exc</span><span class="p">)</span>

    <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
        <span class="k">pass</span>


<span class="k">def</span> <span class="nf">_using_progressbar</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Allows one to call progressbar(iterable, progress) to determine use of progressbar automatically.</span>
<span class="sd">    </span>
<span class="sd">    Checks to see if we are in a python notebook or not to determine which progressbar we should use.</span>
<span class="sd">    Copied from: https://stackoverflow.com/questions/15411967/how-can-i-check-if-code-is-executed-in-the-ipython-notebook</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">progress</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>

    <span class="k">global</span> <span class="n">_IMPORT_PROGRESSBAR</span>
    <span class="k">if</span> <span class="n">_IMPORT_PROGRESSBAR</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_tqdm_import</span> <span class="o">=</span> <span class="n">get_module</span><span class="p">(</span><span class="s1">&#39;tqdm&#39;</span><span class="p">)</span>
            <span class="n">_IMPORT_PROGRESSBAR</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="nb">iter</span><span class="p">(</span><span class="n">_tqdm_import</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Could not import tqdm!&quot;</span><span class="p">)</span>
            <span class="n">_IMPORT_PROGRESSBAR</span> <span class="o">=</span> <span class="nb">iter</span>
    
    <span class="k">return</span> <span class="n">_IMPORT_PROGRESSBAR</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>

<span class="n">progressbar</span> <span class="o">=</span> <span class="n">_using_progressbar</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Justin Allen.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>