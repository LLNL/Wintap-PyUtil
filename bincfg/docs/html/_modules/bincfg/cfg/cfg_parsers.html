<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>bincfg.cfg.cfg_parsers &mdash; BinCFG 0.1.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> BinCFG
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../bincfg.cfg.html">bincfg.cfg package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bincfg.utils.html">bincfg.utils package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bincfg.normalization.html">bincfg.normalization package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bincfg.labeling.html">bincfg.labeling package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">BinCFG</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">bincfg.cfg.cfg_parsers</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for bincfg.cfg.cfg_parsers</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Functions to parse cfg inputs into ``CFG`` objects.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">html</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">bincfg</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">.cfg_function</span> <span class="kn">import</span> <span class="n">CFGFunction</span>
<span class="kn">from</span> <span class="nn">.cfg_basic_block</span> <span class="kn">import</span> <span class="n">CFGBasicBlock</span><span class="p">,</span> <span class="n">RE_RETURN_INSTRUCTION</span>
<span class="kn">from</span> <span class="nn">.cfg_edge</span> <span class="kn">import</span> <span class="n">CFGEdge</span><span class="p">,</span> <span class="n">EdgeType</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="kn">import</span> <span class="n">get_address</span><span class="p">,</span> <span class="n">get_module</span>


<span class="n">DIGRAPH_START_STRINGS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;digraph&#39;</span><span class="p">,</span> <span class="s1">&#39;graph&#39;</span><span class="p">,</span> <span class="s1">&#39;node&#39;</span><span class="p">,</span> <span class="s1">&#39;edge&#39;</span><span class="p">]</span>

<span class="c1"># Regex matches</span>
<span class="n">FUNC_STR_MATCH</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;label=&quot;.*</span><span class="se">\\</span><span class="s1">&quot;&quot;&#39;</span><span class="p">)</span>
<span class="n">FUNC_STR_MATCH_NO_NAME</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;label=&quot;function 0x[0-9a-fA-F]*&quot;&#39;</span><span class="p">)</span>
<span class="n">ASM_LINE_MATCH</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;label=&lt;.*/&gt;&gt;&#39;</span><span class="p">)</span>
<span class="n">FUNCTIONLESS_GV_BLOCK</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;V_0x[0-9a-fA-F]* \[ .*&#39;</span><span class="p">)</span>

<span class="c1"># List of strings that are names for &#39;indeterminate&#39; nodes</span>
<span class="n">INDETERMINATE</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;indeterminate&#39;</span><span class="p">,</span> <span class="s1">&#39;nonexisting&#39;</span><span class="p">]</span>

<span class="c1"># Map a rose name to its in/out edge type ints</span>
<span class="n">ROSE_EDGE_TYPES</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;call&#39;</span><span class="p">:</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">FUNCTION_CALL</span><span class="p">,</span>
    <span class="s1">&#39;cret&#39;</span><span class="p">:</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">NORMAL</span><span class="p">,</span>
    <span class="s1">&#39;cret</span><span class="se">\\</span><span class="s1">nassumed&#39;</span><span class="p">:</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">NORMAL</span><span class="p">,</span>
    <span class="s1">&#39;&#39;</span><span class="p">:</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">NORMAL</span><span class="p">,</span>
    <span class="s1">&#39;other&#39;</span><span class="p">:</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">NORMAL</span>
<span class="p">}</span>

<span class="c1"># Regular expressions that denote an external function</span>
<span class="n">EXTERN_FUNC_NAME_REGEXS</span> <span class="o">=</span> <span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.*@plt&#39;</span><span class="p">),</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.*@.*[.]dll&#39;</span><span class="p">)]</span>


<div class="viewcode-block" id="parse_cfg_data"><a class="viewcode-back" href="../../../bincfg.cfg.html#bincfg.cfg.cfg_parsers.parse_cfg_data">[docs]</a><span class="k">def</span> <span class="nf">parse_cfg_data</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parses the incoming cfg data. Infers type of data</span>

<span class="sd">    Args:</span>
<span class="sd">        cfg (CFG): the cfg to parse into</span>
<span class="sd">        data (Union[str, Sequence[str], TextIO, pd.DataFrame]): the data to parse, can be:</span>

<span class="sd">            - string: either string with newline characters that will be split on all newlines and treated as either a</span>
<span class="sd">              text or graphviz rose input, or a string with no newline characters that will be treated as a filename.</span>
<span class="sd">              Filenames will be opened as ghidra parquet files if they end with either &#39;.pq&#39; or &#39;.parquet&#39;, and</span>
<span class="sd">              text/graphviz rose input otherwise</span>
<span class="sd">            - Sequence of string: will be treated as already-read-in text/graphviz rose input</span>
<span class="sd">            - open file object: will be read in using `.readlines`, then treated as text/graphviz rose input</span>
<span class="sd">            - pandas dataframe: will be parsed as ghidra parquet file</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: bad ``str`` filename, or an unknown file start string</span>
<span class="sd">        TypeError: bad ``data`` input type</span>
<span class="sd">        CFGParseError: if there is an error during CFG parsing (but data type was inferred correctly)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>

        <span class="c1"># Check for the empty string, and initialize empty</span>
        <span class="k">if</span> <span class="n">data</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">return</span>
            
        <span class="c1"># Check for single string to split on newlines</span>
        <span class="k">if</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span>

        <span class="c1"># Otherwise, assume it is a file</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cfg</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;filepath&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
            
            <span class="c1"># Check for a parquet file</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">endswith</span><span class="p">((</span><span class="s1">&#39;.pq&#39;</span><span class="p">,</span> <span class="s1">&#39;.parquet&#39;</span><span class="p">)):</span>
                <span class="n">func</span> <span class="o">=</span> <span class="n">parse_ghidra_parquet</span>

            <span class="c1"># Otherwise, assume it is a text file</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span> <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data was assumed to be a filename, but that file could not be opened/read!: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

    <span class="c1"># Check for a pandas dataframe</span>
    <span class="k">elif</span> <span class="n">get_module</span><span class="p">(</span><span class="s1">&#39;pandas&#39;</span><span class="p">,</span> <span class="n">raise_err</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="s1">&#39;pandas&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">parse_ghidra_parquet</span>

    <span class="c1"># Check for an open file</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;readlines&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">callable</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">readlines</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span> <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span>

    <span class="c1"># Check for a copy constructor</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">bincfg</span><span class="o">.</span><span class="n">CFG</span><span class="p">):</span>
        <span class="n">cfg</span><span class="o">.</span><span class="n">add_function</span><span class="p">(</span><span class="o">*</span><span class="p">[</span>
            <span class="n">CFGFunction</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">is_extern_func</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="n">_is_extern_function</span><span class="p">,</span> <span class="n">blocks</span><span class="o">=</span><span class="p">[</span>
                <span class="n">CFGBasicBlock</span><span class="p">(</span>
                    <span class="n">address</span><span class="o">=</span><span class="n">block</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> 
                    <span class="n">edges_in</span><span class="o">=</span><span class="p">[(</span><span class="n">e</span><span class="o">.</span><span class="n">from_block</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">to_block</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">edge_type</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">edges_in</span><span class="p">],</span>
                    <span class="n">edges_out</span><span class="o">=</span><span class="p">[(</span><span class="n">e</span><span class="o">.</span><span class="n">from_block</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">to_block</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">edge_type</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">edges_out</span><span class="p">],</span>
                    <span class="n">labels</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">labels</span><span class="p">),</span>
                    <span class="n">asm_lines</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">asm_lines</span><span class="p">),</span>
                <span class="p">)</span> <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">func</span><span class="o">.</span><span class="n">blocks</span>
            <span class="p">])</span> <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">functions_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="p">])</span>

        <span class="c1"># Also need to copy the metadata</span>
        <span class="n">cfg</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># Check for a networkx to read in</span>
    <span class="k">elif</span> <span class="n">get_module</span><span class="p">(</span><span class="s1">&#39;networkx&#39;</span><span class="p">,</span> <span class="n">raise_err</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="s1">&#39;networkx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">)):</span>
        <span class="n">bincfg</span><span class="o">.</span><span class="n">CFG</span><span class="o">.</span><span class="n">from_networkx</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cfg</span><span class="p">)</span>
        <span class="k">return</span>
    
    <span class="c1"># Check for a dictionary to read in</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">bincfg</span><span class="o">.</span><span class="n">CFG</span><span class="o">.</span><span class="n">from_cfg_dict</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cfg</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># Otherwise, assume it is a sequence of string lines</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">data</span> <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Could not parse CFG data from data of type: &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
    
    <span class="c1"># If data is a list right now, assume we need to get the function from a list of lines</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">_get_parse_func_from_lines</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    
    <span class="n">func</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_get_parse_func_from_lines</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the function that should be used to parse this list of lines.</span>

<span class="sd">    Assumes all empty lines have already been stripped/removed</span>

<span class="sd">    Args:</span>
<span class="sd">        lines (Sequence[str]): the list of lines</span>

<span class="sd">    Returns:</span>
<span class="sd">        Callable[[CFG, Any], None]: the function to use to parse</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># If lines is empty, return a function that does nothing</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="kc">None</span>
    
    <span class="c1"># Otherwise check for different start lines</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;digraph&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">parse_rose_gv</span>
        <span class="k">elif</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;function&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">parse_rose_txt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown file start string, could not infer file type!:</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s2">...&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="mi">100</span><span class="p">]))</span>


<span class="c1">##################</span>
<span class="c1"># Rose Text File #</span>
<span class="c1">##################</span>


<div class="viewcode-block" id="parse_rose_txt"><a class="viewcode-back" href="../../../bincfg.cfg.html#bincfg.cfg.cfg_parsers.parse_rose_txt">[docs]</a><span class="k">def</span> <span class="nf">parse_rose_txt</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">lines</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Reads input as a .txt file</span>

<span class="sd">    Args:</span>
<span class="sd">        cfg (CFG): an empty/loading CFG() object</span>
<span class="sd">        lines (str, Iterable[str], TextIO): the data to parse. Can be a string (which will be split on newlines to get each</span>
<span class="sd">            individual line), a list of string (each element will be considered one line), or an open file to call</span>
<span class="sd">            `.readlines()` on</span>

<span class="sd">    Raises:</span>
<span class="sd">        CFGParseError: when file does not fit expected format</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="s1">&#39;readlines&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">callable</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="s1">&#39;readlines&#39;</span><span class="p">):</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Clean up the lines a bit</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lines</span> <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Could not parse rose txt input of type: &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

    <span class="n">cfg</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;file_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;txt&#39;</span>
    
    <span class="c1"># Make the dictionary of the current blocks</span>
    <span class="n">curr_blocks</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">funcs</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># Go through lines finding each function</span>
    <span class="n">curr_func_lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        
        <span class="c1"># Make the next function with the current list of lines</span>
        <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;function 0x&#39;</span><span class="p">):</span>
            <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_parse_txt_function</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">curr_func_lines</span><span class="p">,</span> <span class="n">curr_blocks</span><span class="p">))</span>
            <span class="n">curr_func_lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">line</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curr_func_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
    
    <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_parse_txt_function</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">curr_func_lines</span><span class="p">,</span> <span class="n">curr_blocks</span><span class="p">))</span>
    <span class="n">cfg</span><span class="o">.</span><span class="n">add_function</span><span class="p">(</span><span class="o">*</span><span class="n">funcs</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_parse_txt_function</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">func_lines</span><span class="p">,</span> <span class="n">curr_blocks</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parses the function lines from a rose txt file into a ``CFGFunction``, and returns the function</span>

<span class="sd">    Args:</span>
<span class="sd">        cfg (CFG): the ``CFG`` to which this function would belong</span>
<span class="sd">        func_lines (List[str]): list of string lines from file to parse for this function</span>
<span class="sd">        curr_blocks (Dict[int, CFGBasicBlock]): a dictionary mapping basic block addresses to ``CFGBasicBlock`` objects. </span>
<span class="sd">            We need this to create new basic blocks on the fly in order to make ``CFGEdge``&#39;s work properly</span>

<span class="sd">    Returns:</span>
<span class="sd">        CFGFunction: the cfg function</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create the CFGFunction() object with its parent_cfg, name (while removing quotes from rose text), and is_extern_func</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="o">*</span><span class="n">func_name_lines</span> <span class="o">=</span> <span class="n">func_lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">func_name_lines</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">func_name_lines</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">CFGFunction</span><span class="p">(</span><span class="n">parent_cfg</span><span class="o">=</span><span class="n">cfg</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">get_address</span><span class="p">(</span><span class="n">address</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">is_extern_func</span><span class="o">=</span><span class="n">_is_extern_func_name</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

    <span class="c1"># Build up every basic block</span>
    <span class="n">curr_block_lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">func_lines</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">func_lines</span><span class="p">[</span><span class="mi">2</span><span class="p">:]:</span>
        <span class="c1"># Make the next block</span>
        <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">):</span>
            <span class="c1"># Check if this is the first basic block and has the same starting address as the function</span>
            <span class="n">_parse_txt_block</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">curr_block_lines</span><span class="p">,</span> <span class="n">curr_blocks</span><span class="p">)</span>
            <span class="n">curr_block_lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">line</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curr_block_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
    
    <span class="c1"># Add in final block</span>
    <span class="n">_parse_txt_block</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">curr_block_lines</span><span class="p">,</span> <span class="n">curr_blocks</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">func</span>


<span class="k">def</span> <span class="nf">_parse_txt_block</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">block_lines</span><span class="p">,</span> <span class="n">curr_blocks</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parses the incoming block lines from a rose text file, and appends it to func&#39;s blocks</span>

<span class="sd">    Args:</span>
<span class="sd">        func (CFGFunction): the function to which this basic block belongs</span>
<span class="sd">        block_lines (List[str]): list of string block lines to build this block from</span>
<span class="sd">        curr_blocks (Dict[int, CFGBasicBlock]): a dictionary mapping basic block addresses to ``CFGBasicBlock`` objects. </span>
<span class="sd">            We need this to create new basic blocks on the fly in order to make ``CFGEdge``&#39;s work properly</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: on an unknown edge line</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Parse the block name and address, and check if it is a function entry point</span>
    <span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="n">block_address</span> <span class="o">=</span> <span class="n">block_lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
    <span class="n">address</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">address</span> <span class="k">if</span> <span class="n">block_address</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;p&#39;</span> <span class="k">else</span> <span class="n">block_address</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">block_address</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;:&#39;</span> <span class="k">else</span> <span class="n">block_address</span>

    <span class="n">block</span> <span class="o">=</span> <span class="n">_create_basic_block</span><span class="p">(</span><span class="n">curr_blocks</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">get_address</span><span class="p">(</span><span class="n">address</span><span class="p">),</span> <span class="n">parent_function</span><span class="o">=</span><span class="n">func</span><span class="p">)</span>
    
    <span class="c1"># If block is None, then this block already exists in another function, no need to recreate it</span>
    <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">block_lines</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>

        <span class="c1"># If this line is to tell us that this is a function return block &quot;block is a function return/call&quot;</span>
        <span class="k">if</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span>
            <span class="k">continue</span>
        
        <span class="c1"># This is an assembly line. Add the memory address and string line as a tuple</span>
        <span class="c1"># IMPORTANT: do this before the &quot; edge &quot; detection in case of string literals in rose &lt;&gt; info</span>
        <span class="k">elif</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;0x&quot;</span><span class="p">):</span>
            <span class="n">address</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">asm_line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s2">&quot;: &quot;</span><span class="p">)</span>
            <span class="n">block</span><span class="o">.</span><span class="n">asm_lines</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">get_address</span><span class="p">(</span><span class="n">address</span><span class="p">),</span> <span class="n">asm_line</span><span class="o">.</span><span class="n">strip</span><span class="p">()))</span>
        
        <span class="c1"># Currently just ignoring the &#39;also_owned_by&#39; for now</span>
        <span class="k">elif</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span>
            <span class="c1">#owned_by = line[23:].partition(&quot; &quot;)[0]</span>
            <span class="c1">#block.also_owned_by.add(int(owned_by, 16))</span>
            <span class="k">pass</span>
        
        <span class="c1"># Otherwise this must be an edge line</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Check for &quot;function entry point&quot;, then lines using function names in quotes, then just normal address</span>
            <span class="n">edge_addr</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">parent_function</span><span class="o">.</span><span class="n">address</span> <span class="k">if</span> <span class="n">line</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span> <span class="k">else</span> \
                <span class="n">line</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s1">&#39; &quot;&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">line</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&quot;&#39;</span> <span class="k">else</span> <span class="n">line</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            
            <span class="c1"># edge_addr might already be an int from it&#39;s parent address</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edge_addr</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="c1"># Check for indeterminate/nonexistant edges. We ignore these, but check to see if this is a function return</span>
                <span class="k">if</span> <span class="n">edge_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span> <span class="ow">and</span> <span class="n">line</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span>  <span class="c1"># Check for &#39;function return edge to indeterminate&#39;</span>
                        <span class="k">assert</span> <span class="n">RE_RETURN_INSTRUCTION</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">asm_lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="n">block</span><span class="o">.</span><span class="n">asm_lines</span>
                    <span class="k">continue</span>

                <span class="c1"># Convert edge_addr to int</span>
                <span class="n">edge_addr</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">edge_addr</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
            
            <span class="c1"># Check for lines like &quot;function call edge from/to&quot;, and &quot;function return edge to&quot; </span>
            <span class="k">if</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">line</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">line</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span>
                        <span class="n">block</span><span class="o">.</span><span class="n">edges_out</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">CFGEdge</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">_create_basic_block</span><span class="p">(</span><span class="n">curr_blocks</span><span class="p">,</span> <span class="n">edge_addr</span><span class="p">),</span> 
                            <span class="n">edge_type</span><span class="o">=</span><span class="n">EdgeType</span><span class="o">.</span><span class="n">FUNCTION_CALL</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">RE_RETURN_INSTRUCTION</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">asm_lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            
            <span class="c1"># Check for &quot;call return edge to&quot; or &quot;normal edge to&quot;</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span> <span class="ow">and</span> <span class="n">line</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span> <span class="ow">and</span> <span class="n">line</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span><span class="p">):</span>
                <span class="n">block</span><span class="o">.</span><span class="n">edges_out</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">CFGEdge</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">_create_basic_block</span><span class="p">(</span><span class="n">curr_blocks</span><span class="p">,</span> <span class="n">edge_addr</span><span class="p">),</span> <span class="n">edge_type</span><span class="o">=</span><span class="n">EdgeType</span><span class="o">.</span><span class="n">NORMAL</span><span class="p">))</span>
            
            <span class="c1"># Check to make sure this line is an &#39;edge from&#39; line. Otherwise this is an unknown line, raise an error</span>
            <span class="k">elif</span> <span class="s1">&#39;edge from&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown edge line: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>
    
    <span class="n">func</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_create_basic_block</span><span class="p">(</span><span class="n">curr_blocks</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks if there is a basic block with the given address in `curr_blocks`, and if not, creates it. Returns the block</span>

<span class="sd">    If the block does exist, then any kwargs in ``kwargs`` will be updated in the CFGBasicBlock, unless that block already</span>
<span class="sd">    has a parent_func in which case None will be returned and no blocks will be updated</span>

<span class="sd">    Args:</span>
<span class="sd">        curr_blocks (Dict[int, CFGBasicBlock]): curr_blocks: a dictionary mapping basic block addresses to </span>
<span class="sd">            ``CFGBasicBlock`` objects. We need this to create new basic blocks on the fly in order to make </span>
<span class="sd">            ``CFGEdge``&#39;s work properly</span>
<span class="sd">        address (int): the integer memory address of the new basic block</span>
<span class="sd">        kwargs (Any): extra kwargs to pass to ``CFGBasicBlock`` object creation, or to update an already existing </span>
<span class="sd">            CFGBasicBlock</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: _description_</span>

<span class="sd">    Returns:</span>
<span class="sd">        CFGBasicBlock: _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">address</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">curr_blocks</span><span class="p">:</span>
        <span class="n">curr_blocks</span><span class="p">[</span><span class="n">address</span><span class="p">]</span> <span class="o">=</span> <span class="n">CFGBasicBlock</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="n">address</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">curr_blocks</span><span class="p">[</span><span class="n">address</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">curr_blocks</span><span class="p">[</span><span class="n">address</span><span class="p">]</span><span class="o">.</span><span class="n">parent_function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;parent_function&#39;</span><span class="p">,</span> <span class="s1">&#39;edges_in&#39;</span><span class="p">,</span> <span class="s1">&#39;edges_out&#39;</span><span class="p">,</span> <span class="s1">&#39;asm_lines&#39;</span><span class="p">,</span> <span class="s1">&#39;labels&#39;</span><span class="p">]:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">curr_blocks</span><span class="p">[</span><span class="n">address</span><span class="p">],</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown basic block kwarg: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">curr_blocks</span><span class="p">[</span><span class="n">address</span><span class="p">]</span>


<span class="c1">######################</span>
<span class="c1"># Rose Graphviz File #</span>
<span class="c1">######################</span>


<div class="viewcode-block" id="parse_rose_gv"><a class="viewcode-back" href="../../../bincfg.cfg.html#bincfg.cfg.cfg_parsers.parse_rose_gv">[docs]</a><span class="k">def</span> <span class="nf">parse_rose_gv</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">lines</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Reads input as a graphviz file</span>

<span class="sd">    Args:</span>
<span class="sd">        cfg (CFG): an empty/loading CFG() object</span>
<span class="sd">        lines (str, Iterable[str], TextIO): the data to parse. Can be a string (which will be split on newlines to get each</span>
<span class="sd">            individual line), a list of string (each element will be considered one line), or an open file to call</span>
<span class="sd">            `.readlines()` on</span>

<span class="sd">    Raises:</span>
<span class="sd">        CFGParseError: when the file cannot be parsed correctly</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="s1">&#39;readlines&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">callable</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="s1">&#39;readlines&#39;</span><span class="p">):</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Clean up the lines a bit</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lines</span> <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Could not parse rose graphviz input of type: &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

    <span class="n">cfg</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;file_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;gv&#39;</span>

    <span class="n">subgraphs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">curr_blocks</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="c1"># Keeping track of states</span>
    <span class="n">in_subgraph</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">eof</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
        <span class="c1"># Check for empty string, for beginning digraph strings to ignore, and indeterminate/nonexisting nodes</span>
        <span class="k">if</span> <span class="n">line</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">DIGRAPH_START_STRINGS</span> <span class="o">+</span> <span class="n">INDETERMINATE</span><span class="p">):</span>
            <span class="k">continue</span>
        
        <span class="c1"># Check for subgraph cluster</span>
        <span class="k">elif</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
            <span class="n">in_subgraph</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Get the function string</span>
            <span class="n">func_str_matches</span> <span class="o">=</span> <span class="n">FUNC_STR_MATCH</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

            <span class="c1"># Check for functions with no name</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">func_str_matches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">func_str_matches</span> <span class="o">=</span> <span class="n">FUNC_STR_MATCH_NO_NAME</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            
            <span class="c1"># Otherwise continue normally</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">func_str_matches</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">CFGParseError</span><span class="p">(</span><span class="s2">&quot;Could not parse function string from: </span><span class="si">%s</span><span class="se">\n</span><span class="s2"> Found matches: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">line</span><span class="p">),</span> <span class="n">func_str_matches</span><span class="p">))</span>

            <span class="c1"># Add a new subgraph to the list (getting the [7:-1] works in both named and unnamed cases)</span>
            <span class="c1"># The func_str should be something like &#39;function [MEMORY_ADDRESS] &quot;[FUNCTION_NAME]&quot;&#39; or &#39;function [MEMORY_ADDRESS]&#39;</span>
            <span class="n">func_str</span> <span class="o">=</span> <span class="n">func_str_matches</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">7</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">func_address</span><span class="p">,</span> <span class="o">*</span><span class="n">func_name</span> <span class="o">=</span> <span class="n">func_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="n">func_name</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">func_name</span><span class="p">)[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="n">func_name</span> <span class="k">else</span> <span class="kc">None</span>

            <span class="n">subgraphs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">func_name</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">func_address</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">[]))</span>
        
        <span class="c1"># Check for end of subgraph cluster/eof</span>
        <span class="k">elif</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;}&#39;</span><span class="p">:</span>
            <span class="c1"># Check to make sure there is only one eof &#39;}&#39; line</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">in_subgraph</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">eof</span><span class="p">:</span>
                    <span class="n">eof</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">CFGParseError</span><span class="p">(</span><span class="s2">&quot;Found multiple lines starting with &#39;}&#39; that did not end subgraphs&quot;</span><span class="p">)</span>

            <span class="n">in_subgraph</span> <span class="o">=</span> <span class="kc">False</span>
        
        <span class="c1"># Check for nodes/node edges</span>
        <span class="k">elif</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;V&#39;</span><span class="p">:</span>
            
            <span class="c1"># Handle subgraph node, or if it is a block with no parent function</span>
            <span class="k">if</span> <span class="n">in_subgraph</span> <span class="ow">or</span> <span class="n">FUNCTIONLESS_GV_BLOCK</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                <span class="c1"># Get the node address</span>
                <span class="n">address</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s2">&quot; [ &quot;</span><span class="p">)</span>
                <span class="n">address</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">address</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="mi">0</span><span class="p">)</span>
                
                <span class="c1"># Get the asm line string</span>
                <span class="n">asm_line_match</span> <span class="o">=</span> <span class="n">ASM_LINE_MATCH</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span>

                <span class="c1"># Need to leave the first and last &lt;&gt;</span>
                <span class="n">asm_line</span> <span class="o">=</span> <span class="n">asm_line_match</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">6</span><span class="p">:]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">asm_line_match</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>

                <span class="c1"># The tuple for this current node</span>
                <span class="n">node_tup</span> <span class="o">=</span> <span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">asm_line</span><span class="p">)</span>

                <span class="c1"># Add this node to our current subgraph if we are in one</span>
                <span class="k">if</span> <span class="n">in_subgraph</span><span class="p">:</span>
                    <span class="n">subgraphs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_tup</span><span class="p">)</span>
                
                <span class="c1"># Otherwise, we are parsing a functionless basic block, create a dummy function to wrap it</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">subgraphs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;__DUMMY_FUNCTION_AT_0x</span><span class="si">%x</span><span class="s2">__&quot;</span> <span class="o">%</span> <span class="n">address</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="p">[</span><span class="n">node_tup</span><span class="p">]))</span>

            <span class="c1"># Handle edge</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Get the source and destination names</span>
                <span class="n">source</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;-&gt;&#39;</span><span class="p">)]</span>
                <span class="n">dest</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">rest</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; [ &#39;</span><span class="p">)]</span>

                <span class="c1"># Get the label name by splitting on quotes and getting first index, checking for empty string as well</span>
                <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="s1">&#39;label=&quot;&quot;&#39;</span> <span class="ow">in</span> <span class="n">rest</span> <span class="k">else</span> <span class="n">rest</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># Don&#39;t deal with indeterminate edges, unless they are a function return, then send that info</span>
                <span class="k">if</span> <span class="n">dest</span> <span class="ow">in</span> <span class="n">INDETERMINATE</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">source</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">source</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="mi">0</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">dest</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="mi">0</span><span class="p">)</span>

                <span class="c1"># Add the edge into the dictionary for the outgoing edge</span>
                <span class="n">edges</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ROSE_EDGE_TYPES</span><span class="p">[</span><span class="n">label</span><span class="p">],</span> <span class="n">dest</span><span class="p">))</span>

        <span class="c1"># Otherwise, raise error</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CFGParseError</span><span class="p">(</span><span class="s2">&quot;Unknown line: &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">line</span><span class="p">)</span>
    
    <span class="n">funcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">_parse_gv_function</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">curr_blocks</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">nodes</span> <span class="ow">in</span> <span class="n">subgraphs</span><span class="p">]</span>
    <span class="n">cfg</span><span class="o">.</span><span class="n">add_function</span><span class="p">(</span><span class="o">*</span><span class="n">funcs</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_parse_gv_function</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">curr_blocks</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parses the func_info as a graphviz dot file, returns the function</span>

<span class="sd">    Args:</span>
<span class="sd">        cfg (CFG): the ``CFG`` to which this function belongs</span>
<span class="sd">        name (Union[str, None]): the function name, or None if it doesn&#39;t have one</span>
<span class="sd">        address (int): the integer address of this function</span>
<span class="sd">        nodes (Iterable[Tuple[int, str]]): an iterable of nodes in this subgraph. Each &#39;node&#39; should be a tuple of </span>
<span class="sd">            (node_address: int, node_asm_lines: str), with the &#39;node_asm_lines&#39; being the unprocessed string from the </span>
<span class="sd">            graphviz file</span>
<span class="sd">        edges (Dict[int, List[Tuple[EdgeType, int]]]): a dictionary of all edges in the cfg. Each key should be a &#39;from&#39;</span>
<span class="sd">            basic block integer address, and values are tuples of outgoing edge information for the block with that </span>
<span class="sd">            address. Each edge information is a tuple of (edge_type: EdgeType, to_address: int)</span>
<span class="sd">        curr_blocks (Dict[int, CFGBasicBlock]): a dictionary mapping basic block addresses to ``CFGBasicBlock`` objects. </span>
<span class="sd">            We need this to create new basic blocks on the fly in order to make ``CFGEdge``&#39;s work properly</span>

<span class="sd">    Returns:</span>
<span class="sd">        CFGFunction: the cfg function</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">CFGFunction</span><span class="p">(</span><span class="n">parent_cfg</span><span class="o">=</span><span class="n">cfg</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">get_address</span><span class="p">(</span><span class="n">address</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">is_extern_func</span><span class="o">=</span><span class="n">_is_extern_func_name</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">address</span><span class="p">,</span> <span class="n">asm_lines</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
        <span class="n">_parse_gv_block</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">asm_lines</span><span class="p">,</span> <span class="n">edges</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="p">[]),</span> <span class="n">curr_blocks</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">func</span>


<span class="k">def</span> <span class="nf">_parse_gv_block</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">asm_lines</span><span class="p">,</span> <span class="n">node_edges</span><span class="p">,</span> <span class="n">curr_blocks</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parses the incoming block info assuming it is from a graphviz dot file, and appends it to func&#39;s blocks</span>

<span class="sd">    Args:</span>
<span class="sd">        func (CFGFunction): the ``CFGFunction`` this block belongs to</span>
<span class="sd">        address (int): integer memory address of the node</span>
<span class="sd">        asm_lines (str): the UNPARSED asm lines from the raw gv dot file</span>
<span class="sd">        node_edges (Iterable[Tuple[EdgeType, int]]): an iterable of information for all outgoing edges for this block. </span>
<span class="sd">            Each element should be a tuple of (edge_type: EdgeType, to_address: int)</span>
<span class="sd">        curr_blocks (Dict[int, CFGBasicBlock]): a dictionary mapping basic block addresses to ``CFGBasicBlock`` objects. </span>
<span class="sd">            We need this to create new basic blocks on the fly in order to make ``CFGEdge``&#39;s work properly</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the CFGBasicBlock with this address</span>
    <span class="n">block</span> <span class="o">=</span> <span class="n">_create_basic_block</span><span class="p">(</span><span class="n">curr_blocks</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">parent_function</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="n">asm_lines</span><span class="o">=</span><span class="n">get_asm_from_node_label</span><span class="p">(</span><span class="n">asm_lines</span><span class="p">))</span>

    <span class="c1"># Parse out the edges</span>
    <span class="k">for</span> <span class="n">edge_type</span><span class="p">,</span> <span class="n">address</span> <span class="ow">in</span> <span class="n">node_edges</span><span class="p">:</span>
        <span class="n">block</span><span class="o">.</span><span class="n">edges_out</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">CFGEdge</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">_create_basic_block</span><span class="p">(</span><span class="n">curr_blocks</span><span class="p">,</span> <span class="n">address</span><span class="p">),</span> <span class="n">edge_type</span><span class="p">))</span>
    
    <span class="n">func</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>


<span class="n">GV_SPLIT</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;&lt;br [^&gt;]*/&gt;&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="get_asm_from_node_label"><a class="viewcode-back" href="../../../bincfg.cfg.html#bincfg.cfg.cfg_parsers.get_asm_from_node_label">[docs]</a><span class="k">def</span> <span class="nf">get_asm_from_node_label</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts a node&#39;s label into a list of assembly lines at that basic block.</span>

<span class="sd">    Args:</span>
<span class="sd">        label (str): the unparsed string label</span>

<span class="sd">    Returns:</span>
<span class="sd">        List[Tuple[int, str]]: a list of 2-tuples of (memory_address, asm_instruction)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span> <span class="ow">or</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="c1"># Remove the first and last &lt;&gt;, replace all &quot;??&quot; with empty string, and html-unescape the ampersand encoded things</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;0x&#39;</span> <span class="o">+</span> <span class="n">html</span><span class="o">.</span><span class="n">unescape</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;??&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)))</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">GV_SPLIT</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="n">l</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">]</span>

    <span class="c1"># Split on spaces and get the first one to get the memory address, the rest are joined to be the instruction</span>
    <span class="k">return</span> <span class="p">[(</span><span class="nb">int</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ret</span> <span class="k">for</span> <span class="n">addr</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)]]</span></div>


<span class="c1">###################</span>
<span class="c1"># BB Parquet File #</span>
<span class="c1">###################</span>


<div class="viewcode-block" id="parse_ghidra_parquet"><a class="viewcode-back" href="../../../bincfg.cfg.html#bincfg.cfg.cfg_parsers.parse_ghidra_parquet">[docs]</a><span class="k">def</span> <span class="nf">parse_ghidra_parquet</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parses a CFG from a single ghidra output parquet file</span>

<span class="sd">    Args:</span>
<span class="sd">        cfg (CFG): prebuilt ``CFG`` object to modify</span>
<span class="sd">        data (Union[str, pd.DataFrame]): a pandas dataframe loaded from a ghidra parquet file, or a string path </span>
<span class="sd">            to one to load</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: bad `data` input type</span>

<span class="sd">    Returns:</span>
<span class="sd">        CFG: parsed ``CFG`` object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pd</span> <span class="o">=</span> <span class="n">get_module</span><span class="p">(</span><span class="s1">&#39;pandas&#39;</span><span class="p">,</span> <span class="n">err_message</span><span class="o">=</span><span class="s1">&#39;Package is required to parse ghidra parquet data!&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_parquet</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> 
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can only parse ghidra data from loaded pandas dataframe, or string path to parquet file, not &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
    
    <span class="c1"># Dictionaries mapping addresses to block/function objects</span>
    <span class="n">curr_blocks</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">funcs</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># Create graph and parse the functions</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
        <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_parse_ghidra_function</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">func_name</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">func_addr_start</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">16</span><span class="p">),</span> 
            <span class="n">data</span><span class="o">.</span><span class="n">basic_blocks</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">curr_blocks</span><span class="p">))</span>

    <span class="c1"># Add in the extra functions that were referenced, but don&#39;t exist. These should all be single basic blocks with</span>
    <span class="c1">#   no parent function</span>
    <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">curr_blocks</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">parent_function</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">CFGFunction</span><span class="p">(</span><span class="n">parent_cfg</span><span class="o">=</span><span class="n">cfg</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">block</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blocks</span><span class="o">=</span><span class="p">[</span><span class="n">block</span><span class="p">],</span> <span class="n">is_extern_func</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="n">block</span><span class="o">.</span><span class="n">parent_function</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">cfg</span><span class="o">.</span><span class="n">add_function</span><span class="p">(</span><span class="o">*</span><span class="n">funcs</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_parse_ghidra_function</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">basic_blocks</span><span class="p">,</span> <span class="n">curr_blocks</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parses a single function from a ghidra file (IE: one row), returns the function</span>

<span class="sd">    Args:</span>
<span class="sd">        name (str): the name of the function</span>
<span class="sd">        address (int): the integer start address of the function</span>
<span class="sd">        basic_blocks (List[Dict]): the list of basic block dictionaries from the &#39;basic_blocks&#39; key in the dataframe</span>
<span class="sd">        curr_blocks (Dict[int, CFGBasicBlock]): a dictionary mapping basic block addresses to ``CFGBasicBlock`` objects. </span>
<span class="sd">            We need this to create new basic blocks on the fly in order to make ``CFGEdge``&#39;s work properly</span>
<span class="sd">        curr_funcs (Dict[int, CFGFunction]): a dictionary mapping function addresses to ``CFGFunction`` objects. Needed</span>
<span class="sd">            to dynamically create empty dll/so functions on the fly</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">CFGFunction</span><span class="p">(</span><span class="n">parent_cfg</span><span class="o">=</span><span class="n">cfg</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">address</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">basic_blocks</span><span class="p">:</span>
        <span class="n">_parse_ghidra_basic_block</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">curr_blocks</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">func</span>


<span class="k">def</span> <span class="nf">_parse_ghidra_basic_block</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">block_dict</span><span class="p">,</span> <span class="n">curr_blocks</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Reads a basic block dictionary from ghidra data into one or more blocks, adding them all to func&#39;s blocks</span>
<span class="sd">    </span>
<span class="sd">    Might parse into multiple blocks depending on calls. If there is one or more &#39;call&#39; instructions, then each of</span>
<span class="sd">        those partition the basic block into two: one before the call (that includes the &#39;call&#39; instruction), and one</span>
<span class="sd">        after that contains all the remaining instructions (this can happen multiple times if there are more than</span>
<span class="sd">        one call instruction). The block(s) with the call instruction will have a &#39;function call edge&#39; to the associated</span>
<span class="sd">        memory address in &#39;calls_outside_func&#39; dictionary key, and a &#39;call return edge&#39; to subsequent block. </span>
<span class="sd">    The final block will have all of its &#39;successors&#39; put into &#39;normal edges&#39;.</span>

<span class="sd">    Problems/Temporary solutions:</span>
<span class="sd">        1. Block addresses after call splits: when we split a block due to a call operand, the subsequent block will</span>
<span class="sd">            have an address that is not correct. This is because the ghidra data only stores the address of the initial</span>
<span class="sd">            block, not the address of each instruction. I simply increment the address by 1 each time. These will not</span>
<span class="sd">            correspond to the correct starting address for subsequent instructions, but it is unlikely these addresses</span>
<span class="sd">            will ever be used, so I don&#39;t care too much.</span>
<span class="sd">        2. More calls_outside_func than there are call instructions: sometimes, there are more addresses listed in</span>
<span class="sd">            the &#39;calls_outside_func&#39; key than there are call instructions in the assembly lines. This only seems to</span>
<span class="sd">            happen on what I assume are dynamic call addresses like: &#39;call [HEX_ADDRESS]&#39; which I am interpreting as</span>
<span class="sd">            &quot;call the memory address stored at the memory address HEX_ADDRESS&quot;. When something like this happends in</span>
<span class="sd">            rose, it only outputs &quot;function call to indeterminate&quot;, but I&#39;m guessing ghidra is cool and can figure out</span>
<span class="sd">            what the possible call addresses will be. Since I&#39;m not sure if this is what is happening (and if it is, it</span>
<span class="sd">            doesn&#39;t seem possible to figure out which addresses correspond to which call instructions all the time),</span>
<span class="sd">            I instead just assume one address per call instruction in the order they appear in the basic block. This</span>
<span class="sd">            may lead to incorrect edges in some cases, but hopefully it is small/infrequent/inconsequential enough</span>
<span class="sd">            that it won&#39;t mess up training things. In the future, when I figure out how ghidra works, I will come</span>
<span class="sd">            back and fix this.</span>
<span class="sd">        3. Some &#39;calls_outside_func&#39; addresses are weird: some of the addresses in &#39;calls_outside_func&#39; are weird, EG:</span>
<span class="sd">            &#39;0x0000006&#39;, which is not a valid address of a function. I&#39;m guessing these are external function calls, and</span>
<span class="sd">            so whenever they appear, I insert fake functions with a blank nop assembly line in their place.</span>

<span class="sd">    Args:</span>
<span class="sd">        func (CFGFunction): the CFGFunction parent function object containing this block. Assumes that is has </span>
<span class="sd">            already been initialized to have a correct .address attribute</span>
<span class="sd">        block_dict (Dict): the dictionary containing data for a single basic block</span>
<span class="sd">        curr_blocks (Dict[int, CFGBasicBlock]): a dictionary mapping basic block addresses to ``CFGBasicBlock`` objects. </span>
<span class="sd">            We need this to create new basic blocks on the fly in order to make ``CFGEdge``&#39;s work properly</span>

<span class="sd">    Returns:</span>
<span class="sd">        List[CFGBasicBlock]: a list of CFGBasicBlock objects to add to the parent_func</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Parse out the data from the dictionary</span>
    <span class="n">instructions</span> <span class="o">=</span> <span class="n">_parse_ghidra_instructions</span><span class="p">(</span><span class="n">block_dict</span><span class="p">[</span><span class="s1">&#39;instructions&#39;</span><span class="p">])</span>
    <span class="n">block_address</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">block_dict</span><span class="p">[</span><span class="s1">&#39;blk_addr_start&#39;</span><span class="p">],</span> <span class="mi">16</span><span class="p">)</span>
    <span class="n">outside_calls</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">block_dict</span><span class="p">[</span><span class="s1">&#39;calls_outside_func&#39;</span><span class="p">]]</span>
    <span class="n">successors</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">block_dict</span><span class="p">[</span><span class="s1">&#39;successors&#39;</span><span class="p">]]</span>

    <span class="c1"># Iterate through the block, partitioning whenever there is a &#39;call&#39; instruction</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">instructions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

        <span class="c1"># Find the index of either the next call instruction, or the length of the instructions list</span>
        <span class="k">for</span> <span class="n">inst_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">instructions</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">instructions</span><span class="p">[</span><span class="n">inst_idx</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;call&#39;</span><span class="p">):</span>
                <span class="k">break</span>
        <span class="n">inst_idx</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Create a new block and set its address. </span>
        <span class="n">new_block</span> <span class="o">=</span> <span class="n">_create_basic_block</span><span class="p">(</span><span class="n">curr_blocks</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">block_address</span><span class="p">,</span> <span class="n">parent_function</span><span class="o">=</span><span class="n">func</span><span class="p">)</span>

        <span class="c1"># Set this block&#39;s new asm lines, and remove these asm lines from the current list</span>
        <span class="c1"># Increment the block_address counter for the next block if needed</span>
        <span class="n">new_block</span><span class="o">.</span><span class="n">asm_lines</span> <span class="o">=</span> <span class="p">[(</span><span class="n">block_address</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">instructions</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inst_idx</span><span class="p">)]</span>
        <span class="n">instructions</span> <span class="o">=</span> <span class="n">instructions</span><span class="p">[</span><span class="n">inst_idx</span><span class="p">:]</span>
        <span class="n">block_address</span> <span class="o">+=</span> <span class="n">inst_idx</span>

        <span class="c1"># If there was a call, then we need to add a call edge, and pop off the first outside_calls from the list.</span>
        <span class="k">if</span> <span class="n">new_block</span><span class="o">.</span><span class="n">asm_lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;call&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">outside_calls</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">new_block</span><span class="o">.</span><span class="n">edges_out</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">CFGEdge</span><span class="p">(</span><span class="n">new_block</span><span class="p">,</span> <span class="n">_create_basic_block</span><span class="p">(</span><span class="n">curr_blocks</span><span class="p">,</span> <span class="n">outside_calls</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">FUNCTION_CALL</span><span class="p">))</span>
                <span class="n">outside_calls</span> <span class="o">=</span> <span class="n">outside_calls</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

            <span class="c1"># If the call occurs at the very end of the instructions, set the call_return_edges_out to the successor</span>
            <span class="c1">#   (there should be only zero or one successor(s))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">successors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">succ_address</span> <span class="o">=</span> <span class="n">block_address</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">instructions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">successors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">new_block</span><span class="o">.</span><span class="n">edges_out</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">CFGEdge</span><span class="p">(</span><span class="n">new_block</span><span class="p">,</span> <span class="n">_create_basic_block</span><span class="p">(</span><span class="n">curr_blocks</span><span class="p">,</span> <span class="n">succ_address</span><span class="p">),</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">NORMAL</span><span class="p">))</span>
        
        <span class="c1"># Otherwise, this is the end of the block, and just add successors to the &#39;normal_edges_out&#39; </span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_block</span><span class="o">.</span><span class="n">edges_out</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">CFGEdge</span><span class="p">(</span><span class="n">new_block</span><span class="p">,</span> <span class="n">_create_basic_block</span><span class="p">(</span><span class="n">curr_blocks</span><span class="p">,</span> <span class="n">s</span><span class="p">),</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">NORMAL</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">successors</span><span class="p">)</span>
        
        <span class="n">func</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_block</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_parse_ghidra_instructions</span><span class="p">(</span><span class="n">insts_dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parses a list of instructions for a single basic block</span>

<span class="sd">    Appends all of the operator/operand strings together for each instruction, and calls .lower() on them</span>

<span class="sd">    Args:</span>
<span class="sd">        insts_dict (Dict): the instructions dictionary from the basic_block_dict[&#39;instructions&#39;] key</span>

<span class="sd">    Returns:</span>
<span class="sd">        List[str]: a list of string assembly instructions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i_dict</span> <span class="ow">in</span> <span class="n">insts_dict</span><span class="p">:</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">i_dict</span><span class="p">[</span><span class="s1">&#39;operator&#39;</span><span class="p">]</span>
        <span class="n">app</span> <span class="o">+=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([(</span><span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;operand&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">i_dict</span><span class="p">[</span><span class="s1">&#39;operands&#39;</span><span class="p">]])</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">ret</span>


<span class="k">def</span> <span class="nf">_is_extern_func_name</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns True if name is an external function name, False otherwise</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        name (Union[str, None]): the name</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        bool: True if name is an external function name, False otherwise</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">EXTERN_FUNC_NAME_REGEXS</span><span class="p">)</span>


<div class="viewcode-block" id="CFGParseError"><a class="viewcode-back" href="../../../bincfg.cfg.html#bincfg.cfg.cfg_parsers.CFGParseError">[docs]</a><span class="k">class</span> <span class="nc">CFGParseError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Justin Allen.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>