<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>bincfg.cfg.cfg &mdash; BinCFG 0.1.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> BinCFG
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../bincfg.cfg.html">bincfg.cfg package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bincfg.utils.html">bincfg.utils package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bincfg.normalization.html">bincfg.normalization package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bincfg.labeling.html">bincfg.labeling package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">BinCFG</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">bincfg.cfg.cfg</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for bincfg.cfg.cfg</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span><span class="p">,</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">.cfg_parsers</span> <span class="kn">import</span> <span class="n">parse_cfg_data</span>
<span class="kn">from</span> <span class="nn">.cfg_function</span> <span class="kn">import</span> <span class="n">CFGFunction</span>
<span class="kn">from</span> <span class="nn">.cfg_edge</span> <span class="kn">import</span> <span class="n">CFGEdge</span><span class="p">,</span> <span class="n">EdgeType</span>
<span class="kn">from</span> <span class="nn">.cfg_basic_block</span> <span class="kn">import</span> <span class="n">CFGBasicBlock</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="kn">import</span> <span class="n">get_address</span><span class="p">,</span> <span class="n">eq_obj</span><span class="p">,</span> <span class="n">hash_obj</span><span class="p">,</span> <span class="n">AtomicTokenDict</span><span class="p">,</span> <span class="n">get_module</span>
<span class="kn">from</span> <span class="nn">..normalization</span> <span class="kn">import</span> <span class="n">normalize_cfg_data</span><span class="p">,</span> <span class="n">TokenizationLevel</span>
<span class="kn">from</span> <span class="nn">..normalization.base_normalizer</span> <span class="kn">import</span> <span class="n">_Pickled_Normalizer</span>
<span class="kn">from</span> <span class="nn">..labeling.parse_cfg_labels</span> <span class="kn">import</span> <span class="n">parse_node_labels</span>
<span class="kn">from</span> <span class="nn">..labeling.node_labels</span> <span class="kn">import</span> <span class="n">NODE_LABELS_INT_TO_STR</span><span class="p">,</span> <span class="n">NODE_LABELS_STR_TO_INT</span>


<span class="c1"># Info for the get_compressed_stats() method of cfg&#39;s</span>
<span class="n">GRAPH_LEVEL_STATS_FUNCS</span> <span class="o">=</span> <span class="p">[</span>
    <span class="k">lambda</span> <span class="n">cfg</span><span class="p">:</span> <span class="n">cfg</span><span class="o">.</span><span class="n">num_blocks</span><span class="p">,</span>
    <span class="k">lambda</span> <span class="n">cfg</span><span class="p">:</span> <span class="n">cfg</span><span class="o">.</span><span class="n">num_functions</span><span class="p">,</span>
    <span class="k">lambda</span> <span class="n">cfg</span><span class="p">:</span> <span class="n">cfg</span><span class="o">.</span><span class="n">num_asm_lines</span><span class="p">,</span>
<span class="p">]</span>
<span class="n">GLS_DTYPE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span>
<span class="n">NODE_SIZE_HIST_BINS</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">200</span><span class="p">]</span>
<span class="n">FUNCTION_DEGREE_HIST_BINS</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">200</span><span class="p">]</span>
<span class="n">FUNCTION_SIZE_HIST_BINS</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">500</span><span class="p">]</span>

<span class="c1"># Extra bytes to pad the insertion of libraries into the CFG so we don&#39;t mess up other assembly instructions</span>
<span class="n">_INSERTION_PADDING_BYTES</span> <span class="o">=</span> <span class="mi">16</span>


<div class="viewcode-block" id="CFG"><a class="viewcode-back" href="../../../bincfg.cfg.html#bincfg.cfg.cfg.CFG">[docs]</a><span class="k">class</span> <span class="nc">CFG</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A Control Flow Graph (CFG) representation of a binary</span>

<span class="sd">    Can currently load in from:</span>

<span class="sd">        * Rose binary analysis tool (both text and graphviz dotfile outputs)</span>
<span class="sd">    </span>
<span class="sd">    NOTE: &#39;indeterminate&#39; blocks/calls/etc. are completely ignored</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data: `Optional[Union[str, TextIO, Sequence[str], pd.DataFrame]]`</span>
<span class="sd">        the data to use to make this CFG. Data type will be inferred based on the data passed:</span>

<span class="sd">            * string: either string with newline characters that will be split on all newlines and treated as either a</span>
<span class="sd">              text or graphviz rose input, or a string with no newline characters that will be treated as a filename.</span>
<span class="sd">              Filenames will be opened as ghidra parquet files if they end with either &#39;.pq&#39; or &#39;.parquet&#39;, and</span>
<span class="sd">              text/graphviz rose input otherwise</span>
<span class="sd">            * Sequence of string: will be treated as already-read-in text/graphviz rose input</span>
<span class="sd">            * open file object: will be read in using `.readlines`, then treated as text/graphviz rose input</span>
<span class="sd">            * pandas dataframe: will be parsed as ghidra parquet file</span>
<span class="sd">            * anything else: an error will be raised</span>

<span class="sd">    normalizer: `Optional[Union[str, Normalizer]]`</span>
<span class="sd">        the normalizer to use to force-renormalize the incoming CFG, or None to not normalize</span>
<span class="sd">    metadata: `Optional[dict]`</span>
<span class="sd">        a dictionary of metadata to add to this CFG</span>
<span class="sd">        NOTE: passed dictionary will be shallow copied</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">normalizer</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;The normalizer used to normalize assembly lines in this ``CFG``, or None if they have not been normalized&quot;&quot;&quot;</span>

    <span class="n">metadata</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;Dictionary of metadata associated with this ``CFG``&quot;&quot;&quot;</span>

    <span class="n">functions_dict</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;Dictionary mapping integer function addresses to their ``CFGFunction`` objects&quot;&quot;&quot;</span>

    <span class="n">blocks_dict</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;Dictionary mapping integer basic block addresses to their ``CFGBasicBlock`` objects&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normalizer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># These store functions/blocks while allowing for O(1) lookup by address</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blocks_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">normalizer</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">metadata</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">metadata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># If data is not None, parse it</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parse_cfg_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        
        <span class="c1"># Prune any of the padding node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prune_padding_nodes</span><span class="p">()</span>

        <span class="c1"># Check for node labels</span>
        <span class="n">parse_node_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Finally, normalize if needed</span>
        <span class="k">if</span> <span class="n">normalizer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">normalizer</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_prune_padding_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Prunes all of the padding nodes (nodes that only have NOP instructions for alignment)&quot;&quot;&quot;</span>
        <span class="c1"># Got to keep track of the blocks to remove since dictionary will change size</span>
        <span class="n">blocks_to_remove</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocks_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">is_padding_node</span><span class="p">:</span>

                <span class="c1"># Make sure this block has at most one edge out since it should be all NOP&#39;s</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">edges_out</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Found a padding node with &gt; 1 edges out!&quot;</span><span class="p">)</span>
                <span class="n">next_block</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">edges_out</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">list</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">edges_out</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">to_block</span>

                <span class="c1"># Re-edge all of this block&#39;s incomming edges to point to either the one outgoing edge, or none, then</span>
                <span class="c1">#   remove those edges</span>
                <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">edges_in</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">next_block</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">new_edge</span> <span class="o">=</span> <span class="n">CFGEdge</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">from_block</span><span class="p">,</span> <span class="n">next_block</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">edge_type</span><span class="p">)</span>
                        <span class="n">edge</span><span class="o">.</span><span class="n">from_block</span><span class="o">.</span><span class="n">edges_out</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_edge</span><span class="p">)</span>
                        <span class="n">next_block</span><span class="o">.</span><span class="n">edges_in</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_edge</span><span class="p">)</span>
                    <span class="n">edge</span><span class="o">.</span><span class="n">from_block</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">edges_out</span><span class="p">:</span>
                    <span class="n">edge</span><span class="o">.</span><span class="n">to_block</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
                
                <span class="c1"># Remove the block from its function, checking for if it is a function entry</span>
                <span class="n">func</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">parent_function</span>
                <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">is_function_entry</span> <span class="ow">and</span> <span class="n">next_block</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">next_block</span><span class="o">.</span><span class="n">parent_function</span> <span class="ow">is</span> <span class="n">func</span> <span class="ow">and</span> <span class="n">func</span><span class="o">.</span><span class="n">address</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Remove then add the function from the function_dict with new address</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions_dict</span><span class="p">[</span><span class="n">func</span><span class="o">.</span><span class="n">address</span><span class="p">]</span>
                    <span class="n">func</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">next_block</span><span class="o">.</span><span class="n">address</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">functions_dict</span><span class="p">[</span><span class="n">func</span><span class="o">.</span><span class="n">address</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span>
                <span class="n">func</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>

                <span class="c1"># Add the block to those to remove if its address is not None</span>
                <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">address</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">blocks_to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>

        <span class="c1"># Remove all of the padding nodes from the blocks_dict</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">blocks_to_remove</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocks_dict</span><span class="p">[</span><span class="n">block</span><span class="o">.</span><span class="n">address</span><span class="p">]</span>

    
<div class="viewcode-block" id="CFG.get_function"><a class="viewcode-back" href="../../../bincfg.cfg.html#bincfg.cfg.cfg.CFG.get_function">[docs]</a>    <span class="k">def</span> <span class="nf">get_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">raise_err</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the function in this ``CFG`` with the given address</span>

<span class="sd">        Args:</span>
<span class="sd">            address (Union[str, int, Addressable]): a string/integer memory address, or an addressable object </span>
<span class="sd">                (EG: CFGBasicBlock/CFGFunction)</span>
<span class="sd">            raise_err (bool, optional): if True, will raise an error if the function with the given memory address was </span>
<span class="sd">                not found, otherwise will return None. Defaults to True.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if the function with the given address could not be found</span>

<span class="sd">        Returns:</span>
<span class="sd">            Union[CFGFunction, None]: the function with the given address, or None if that function does not exist</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">address</span> <span class="o">=</span> <span class="n">get_address</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">address</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions_dict</span> <span class="ow">and</span> <span class="n">raise_err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Could not find function with address: (decimal) </span><span class="si">%d</span><span class="s2">, (hex) 0x</span><span class="si">%x</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">address</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="CFG.get_function_by_name"><a class="viewcode-back" href="../../../bincfg.cfg.html#bincfg.cfg.cfg.CFG.get_function_by_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_function_by_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">raise_err</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the function in this ``CFG`` with the given name</span>

<span class="sd">        NOTE: if the name of the function is None, then the expected string name to this method would be:</span>
<span class="sd">        &quot;__UNNAMED_FUNC_%d&quot; % func.address</span>

<span class="sd">        Args:</span>
<span class="sd">            name (str): the name of the function to get</span>
<span class="sd">            raise_err (bool, optional): if True, will raise an error if the function with the given memory address was </span>
<span class="sd">                not found, otherwise will return None. Defaults to True.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if the function with the given address could not be found</span>

<span class="sd">        Returns:</span>
<span class="sd">            Union[CFGFunction, None]: the function with the given address, or None if that function does not exist</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">func</span><span class="o">.</span><span class="n">nice_name</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">func</span>
        <span class="k">if</span> <span class="n">raise_err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Could not find function with name: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
        <span class="k">return</span> <span class="kc">None</span></div>
    
<div class="viewcode-block" id="CFG.get_block"><a class="viewcode-back" href="../../../bincfg.cfg.html#bincfg.cfg.cfg.CFG.get_block">[docs]</a>    <span class="k">def</span> <span class="nf">get_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">raise_err</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the basic block in this CFG with the given address</span>

<span class="sd">        Args:</span>
<span class="sd">            address (Union[str, int, Addressable]): a string/integer memory address, or an addressable object </span>
<span class="sd">                (EG: CFGBasicBlock/CFGFunction)</span>
<span class="sd">            raise_err (bool, optional): if True, will raise an error if the basic block with the given memory address </span>
<span class="sd">                was not found, otherwise will return None. Defaults to True.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if the basic block with the given address could not be found</span>

<span class="sd">        Returns:</span>
<span class="sd">            Union[CFGBasicBlock, None]: the basic block with the given address</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">address</span> <span class="o">=</span> <span class="n">get_address</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">address</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocks_dict</span> <span class="ow">and</span> <span class="n">raise_err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Could not find basic block with address: (decimal) </span><span class="si">%d</span><span class="s2">, (hex) </span><span class="si">%x</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">address</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocks_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="CFG.get_block_containing_address"><a class="viewcode-back" href="../../../bincfg.cfg.html#bincfg.cfg.cfg.CFG.get_block_containing_address">[docs]</a>    <span class="k">def</span> <span class="nf">get_block_containing_address</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">raise_err</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the basic block in this CFG that contains the given address at the start of one of its instructions</span>

<span class="sd">        This will lazily compute an instruction lookup dictionary mapping addresses to the blocks that contain them</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            address (Union[str, int, Addressable]): a string/integer memory address, or an addressable object </span>
<span class="sd">                (EG: CFGBasicBlock/CFGFunction)</span>
<span class="sd">            raise_err (bool, optional): if True, will raise an error if the basic block with the given memory address </span>
<span class="sd">                was not found, otherwise will return None. Defaults to True.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if the basic block containing the given address could not be found</span>

<span class="sd">        Returns:</span>
<span class="sd">            Union[CFGBasicBlock, None]: the basic block that contains the given address</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">address</span> <span class="o">=</span> <span class="n">get_address</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>

        <span class="c1"># Check if we have created an instruction lookup yet or not</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_inst_lookup&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">address</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inst_lookup</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inst_lookup</span><span class="p">[</span><span class="n">address</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">raise_err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Could not find basic block containing the address: (decimal) </span><span class="si">%d</span><span class="s2">, (hex) </span><span class="si">%x</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">address</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_inst_lookup</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">block_addr</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">instruction_addresses</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_inst_lookup</span><span class="p">[</span><span class="n">block_addr</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_block_containing_address</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">raise_err</span><span class="o">=</span><span class="n">raise_err</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="CFG.add_function"><a class="viewcode-back" href="../../../bincfg.cfg.html#bincfg.cfg.cfg.CFG.add_function">[docs]</a>    <span class="k">def</span> <span class="nf">add_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">functions</span><span class="p">,</span> <span class="n">override</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds the given function(s) to this cfg. This should only be done once the given function(s) have been fully initialized</span>

<span class="sd">        This will do some housekeeping things such as:</span>

<span class="sd">            * setting the parent_cfg and parent_function attributes of functions and blocks respectively</span>
<span class="sd">            * adding missing edges to their associated edges_out and edges_in</span>
<span class="sd">            * converting edges from (None/address, None/address, edge_type) tuples into CFGEdge() objects</span>
<span class="sd">            * adding from_block and to_block in new edges if missing</span>

<span class="sd">        Args:</span>
<span class="sd">            function (CFGFunction): arbitrary number of CFGFunction&#39;s to add</span>
<span class="sd">            override (bool): if False, an error will be raised if a function or basic block contains an address that</span>
<span class="sd">                already exists in this CFG. If True, then that error will not be raised and those functions/basic blocks</span>
<span class="sd">                will be overriden (which has unsupported behavior). Defaults to False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">functions</span><span class="p">:</span>
            <span class="c1"># Check for bad function type, address being None, or function address already existing</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">CFGFunction</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can only add function of type CFGFunction, not &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">func</span><span class="o">.</span><span class="n">address</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Function cannot have a None address when adding to CFG: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">func</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">func</span><span class="o">.</span><span class="n">address</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions_dict</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">override</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Function has address 0x</span><span class="si">%x</span><span class="s2"> which already exists in this CFG!&quot;</span> <span class="o">%</span> <span class="n">func</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
            
            <span class="n">func</span><span class="o">.</span><span class="n">parent_cfg</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">func</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_func_name</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">functions_dict</span><span class="p">[</span><span class="n">get_address</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">address</span><span class="p">)]</span> <span class="o">=</span> <span class="n">func</span>
            <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">func</span><span class="o">.</span><span class="n">blocks</span><span class="p">:</span>
                <span class="c1"># Check for bad basic blocks</span>
                <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">address</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Block cannot have a None address when adding to CFG: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">block</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">address</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocks_dict</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">override</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Basic block has address 0x</span><span class="si">%x</span><span class="s2"> which already exists in this CFG!&quot;</span> <span class="o">%</span> <span class="n">block</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
                
                <span class="n">block</span><span class="o">.</span><span class="n">parent_function</span> <span class="o">=</span> <span class="n">func</span>
                        
                <span class="bp">self</span><span class="o">.</span><span class="n">blocks_dict</span><span class="p">[</span><span class="n">get_address</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">address</span><span class="p">)]</span> <span class="o">=</span> <span class="n">block</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_blocks</span><span class="p">()</span></div>
    
    <span class="k">def</span> <span class="nf">_check_func_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks if the given function name already exists, and slightly modifies it if so since name collisions cause problems</span>
<span class="sd">        </span>
<span class="sd">        Replaces all None names with _UNNAMED_FUNC_%d with %d being an integer index that counts up for each unnamed function</span>
<span class="sd">        Or, in the case of the first function with None name, it will be called &quot;_UNNAMED_FUNC&quot;</span>

<span class="sd">        Any names that already exist will have a &#39;_%d&#39; appended with %d being an integer</span>

<span class="sd">        Otherwise, just returns the name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;_UNNAMED_FUNC&#39;</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">name</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_temp_func_names&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_temp_func_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_temp_func_names</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_temp_func_names</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
            
            <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">idx</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_func_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">name</span>
    
    <span class="k">def</span> <span class="nf">_update_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates basic blocks in this cfg</span>

<span class="sd">        Specifically, makes sure all the `.edges_out` and `.edges_in` are filled correctly for all basic blocks</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check the edges out</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="p">:</span>
            <span class="n">block</span><span class="o">.</span><span class="n">edges_out</span> <span class="o">=</span> <span class="nb">set</span><span class="p">((</span><span class="n">CFGEdge</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">CFGBasicBlock</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_block</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> \
                                   <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">edges_out</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">edges_out</span><span class="p">:</span>
                <span class="n">edge</span><span class="o">.</span><span class="n">to_block</span><span class="o">.</span><span class="n">edges_in</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

        <span class="c1"># Check the edges in</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="p">:</span>
            <span class="n">block</span><span class="o">.</span><span class="n">edges_in</span> <span class="o">=</span> <span class="nb">set</span><span class="p">((</span><span class="n">CFGEdge</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">CFGBasicBlock</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_block</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">block</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> \
                                  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">edges_in</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">edges_in</span><span class="p">:</span>
                <span class="n">edge</span><span class="o">.</span><span class="n">from_block</span><span class="o">.</span><span class="n">edges_out</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

<div class="viewcode-block" id="CFG.insert_library"><a class="viewcode-back" href="../../../bincfg.cfg.html#bincfg.cfg.cfg.CFG.insert_library">[docs]</a>    <span class="k">def</span> <span class="nf">insert_library</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfg</span><span class="p">,</span> <span class="n">function_mapping</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inserts the cfg of a shared library into this cfg</span>

<span class="sd">        This will modify the memory addresses of `cfg` (adding an appropriate offset), then add all of the functions and</span>
<span class="sd">        basic blocks from `cfg` into this cfg. Finally, external functions in this cfg that have implemented functions</span>
<span class="sd">        in the function_mapping will have normal edges added.</span>

<span class="sd">        NOTE: this assumes that no other libraries will be added later that depend on this one that is currently being</span>
<span class="sd">        added (otherwise, the external function edges might not be added properly). Make sure you add them in the</span>
<span class="sd">        correct order!</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            cfg (CFG): the cfg of the library to insert. It will be copied</span>
<span class="sd">            function_mappping (Dict[str, int]): dictionary mapping known exported function names to their addresses</span>
<span class="sd">                within `cfg`. While we can sometimes determine these mappings from function names in the new `cfg`,</span>
<span class="sd">                that is not always the case (EG: stripping function names from binaries, or compilers/linkers emitting</span>
<span class="sd">                aliases for the functions in `cfg`), hence why this parameter exists. If you don&#39;t wish to add in new</span>
<span class="sd">                normal edges, or if you wish to add them in manually, you can pass an empty dictionary</span>
<span class="sd">            offset (Optional[int]): if None, then the library will be inserted in the first available memory location.</span>
<span class="sd">                Otherwise this can be an integer memory address to insert the cfg at (this will raise an error if it</span>
<span class="sd">                can&#39;t fit there)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine an acceptable offset. We can&#39;t just insert at the end or something since we may call this function</span>
        <span class="c1">#   multiple times, and binaries can do just about anything that may mess up hard-coded placements</span>
        <span class="n">_min_max</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>

        <span class="c1"># Find the size of `cfg` (just the needed memory locations, plus some padding)</span>
        <span class="n">min_addr</span><span class="p">,</span> <span class="n">max_addr</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">64</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">cfg</span><span class="o">.</span><span class="n">blocks</span><span class="p">:</span>
            <span class="n">new_min</span><span class="p">,</span> <span class="n">new_max</span> <span class="o">=</span> <span class="n">_min_max</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">asm_memory_addresses</span><span class="p">)</span>
            <span class="n">min_addr</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">min_addr</span><span class="p">,</span> <span class="n">new_min</span><span class="p">)</span>
            <span class="n">max_addr</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_addr</span><span class="p">,</span> <span class="n">new_max</span><span class="p">)</span>
        <span class="n">cfg_size</span> <span class="o">=</span> <span class="n">max_addr</span> <span class="o">-</span> <span class="n">min_addr</span> <span class="o">+</span> <span class="n">_INSERTION_PADDING_BYTES</span> <span class="o">*</span> <span class="mi">2</span>

        <span class="c1"># Sort all min/max&#39;s of memory addresses for blocks in this cfg. Insert a 0 so we could insert in beginning</span>
        <span class="n">addresses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">_min_max</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">asm_memory_addresses</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">32</span><span class="p">])</span>

        <span class="c1"># If the user didn&#39;t pass an offset, determine an appropriate one on our own</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="c1"># Compute all of the differences to get sizes (all negative or 0 since sorted), get every other one since we </span>
            <span class="c1">#   couldn&#39;t place it inside a block</span>
            <span class="n">diffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">addresses</span><span class="p">)[::</span><span class="mi">2</span><span class="p">]</span>

            <span class="c1"># Find the first spot in which we could place the new cfg, raise an error if we can&#39;t fit it. Get the original</span>
            <span class="c1">#   starting memory address of that location</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">diffs</span> <span class="o">&gt;=</span> <span class="n">cfg_size</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Could not find space to insert a library of size </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">cfg_size</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">addresses</span><span class="p">[</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">_INSERTION_PADDING_BYTES</span>
        
        <span class="c1"># Otherwise, check that the offset the user passed works. It should in an available and large enough gap, and</span>
        <span class="c1">#   should be at least _INSERTION_PADDING_BYTES away from the nearest used memory address in this cfg</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">addresses</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>

            <span class="c1"># If the index is even, then it is within a block (note: addresses is always even length-ed, and the </span>
            <span class="c1">#   searchsorted call will always return the index after the last used memory address). Otherwise if</span>
            <span class="c1">#   idx is within _INSERTION_PADDING_BYTES of the nearest block, then it is also bad</span>
            <span class="c1"># Another note: if the idx is 1, then it doesn&#39;t need the padding since it&#39;s already at the start of the memory,</span>
            <span class="c1">#   but it does need it after for possible instruction lengths</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">addresses</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">idx</span> \
                <span class="ow">and</span> <span class="p">(</span><span class="n">offset</span> <span class="o">-</span> <span class="n">addresses</span><span class="p">[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">_INSERTION_PADDING_BYTES</span> <span class="ow">or</span> <span class="n">addresses</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">cfg_size</span> <span class="o">&lt;</span> <span class="n">_INSERTION_PADDING_BYTES</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="n">InvalidInsertionMemoryAddressError</span><span class="p">(</span><span class="s2">&quot;Cannot insert library at address: 0x</span><span class="si">%x</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">offset</span><span class="p">)</span>

        <span class="c1"># Insert all the new functions/basic blocks, adding offsets to the addresses</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">cfg</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
            <span class="n">new_func</span> <span class="o">=</span> <span class="n">CFGFunction</span><span class="p">(</span><span class="n">parent_cfg</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> 
                                    <span class="n">is_extern_func</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="n">is_extern_function</span><span class="p">,</span> <span class="n">blocks</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">functions_dict</span><span class="p">[</span><span class="n">new_func</span><span class="o">.</span><span class="n">address</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_func</span>

            <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">func</span><span class="o">.</span><span class="n">blocks</span><span class="p">:</span>
                <span class="n">new_block</span> <span class="o">=</span> <span class="n">CFGBasicBlock</span><span class="p">(</span><span class="n">parent_function</span><span class="o">=</span><span class="n">new_func</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">block</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">block</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span>
                                            <span class="n">asm_lines</span><span class="o">=</span><span class="p">[(</span><span class="n">a</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">asm_lines</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">blocks_dict</span><span class="p">[</span><span class="n">new_block</span><span class="o">.</span><span class="n">address</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_block</span>
                <span class="n">new_func</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>

                <span class="c1"># Keep track of the edges, they will be added later with references to the new block objects</span>
                <span class="k">for</span> <span class="n">edge_set</span> <span class="ow">in</span> <span class="p">[</span><span class="n">block</span><span class="o">.</span><span class="n">edges_in</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">edges_out</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edge_set</span><span class="p">:</span>
                        <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">edge</span><span class="o">.</span><span class="n">from_block</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">to_block</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">edge_type</span><span class="p">))</span>
        
        <span class="c1"># Add in the edges for resolved external function symbols</span>
        <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">func</span><span class="o">.</span><span class="n">symbol_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">func</span><span class="o">.</span><span class="n">symbol_name</span> <span class="ow">in</span> <span class="n">function_mapping</span><span class="p">:</span>
                <span class="n">extern_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_function</span><span class="p">(</span><span class="n">function_mapping</span><span class="p">[</span><span class="n">func</span><span class="o">.</span><span class="n">symbol_name</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span>

                <span class="c1"># Assume the function has one block for now, we&#39;ll have to fix that later if that isn&#39;t true</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">blocks</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Attempting to insert resolved symbolic normal edge to external function, but the &quot;</span>
                                        <span class="s2">&quot;external function had </span><span class="si">%d</span><span class="s2"> blocks! (expected 1)&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">blocks</span><span class="p">))</span>
                
                <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">func</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">extern_func</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">NORMAL</span><span class="p">))</span>
        
        <span class="c1"># Add in all of the edges</span>
        <span class="k">for</span> <span class="n">from_addr</span><span class="p">,</span> <span class="n">to_addr</span><span class="p">,</span> <span class="n">edge_type</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">from_block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_block</span><span class="p">(</span><span class="n">from_addr</span><span class="p">)</span>
            <span class="n">to_block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_block</span><span class="p">(</span><span class="n">to_addr</span><span class="p">)</span>
            <span class="n">new_edge</span> <span class="o">=</span> <span class="n">CFGEdge</span><span class="p">(</span><span class="n">from_block</span><span class="p">,</span> <span class="n">to_block</span><span class="p">,</span> <span class="n">edge_type</span><span class="p">)</span>

            <span class="n">from_block</span><span class="o">.</span><span class="n">edges_out</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_edge</span><span class="p">)</span>
            <span class="n">to_block</span><span class="o">.</span><span class="n">edges_in</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_edge</span><span class="p">)</span></div>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">functions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A list of functions in this CFG (in order of memory address)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functions_dict</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A list of basic blocks in this CFG (in order of memory address)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blocks_dict</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of basic blocks in this cfg&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blocks_dict</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of functions in this cfg&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functions_dict</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of edges in this cfg&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">num_edges</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocks_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_asm_lines</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of asm lines across all blocks in this cfg&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">num_asm_lines</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocks_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">asm_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A collections.Counter() of all unique assembly lines and their counts in this cfg&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">((</span><span class="n">f</span><span class="o">.</span><span class="n">asm_counts</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">Counter</span><span class="p">())</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A list of all outgoing ``CFGEdge``&#39;s in this ``CFG``&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">edges_out</span><span class="p">]</span>

<div class="viewcode-block" id="CFG.to_adjacency_matrix"><a class="viewcode-back" href="../../../bincfg.cfg.html#bincfg.cfg.cfg.CFG.to_adjacency_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">to_adjacency_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;np&#39;</span><span class="p">,</span> <span class="n">sparse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an adjacency matrix representation of this cfg&#39;s graph connections</span>

<span class="sd">        Currently is slow because I just convert to a MemCFG, then call that object&#39;s to_adjacency_matrix(). I should</span>
<span class="sd">        probably speed this up at some point...</span>

<span class="sd">        Connections will be directed and have values:</span>

<span class="sd">            - 0: No edge</span>
<span class="sd">            - 1: Normal edge</span>
<span class="sd">            - 2: Function call edge</span>

<span class="sd">        See :func:`bincfg.memcfg.to_adjacency_matrix` for more details</span>

<span class="sd">        Args:</span>
<span class="sd">            type (str, optional): the type of matrix to return. Defaults to &#39;np&#39;. Can be:</span>

<span class="sd">                - &#39;np&#39;/&#39;numpy&#39; for a numpy ndarray (dtype: np.int32)</span>
<span class="sd">                - &#39;torch&#39;/&#39;pytorch&#39; for a pytorch tensor (type: LongTensor)</span>
<span class="sd">            </span>
<span class="sd">            sparse (bool, optional): whether or not the return value should be a sparse matrix. Defaults to False. Has </span>
<span class="sd">                different behaviors based on type:</span>

<span class="sd">                - numpy array: returns a 2-tuple of sparse COO representation (indices, values). </span>
<span class="sd">                    NOTE: if you want sparse CSR format, you already have it with self.graph_c and self.graph_r</span>
<span class="sd">                - pytorch tensor: returns a pytorch sparse COO tensor. </span>
<span class="sd">                    NOTE: not using sparse CSR format for now since it seems to have less documentation/supportedness. </span>

<span class="sd">        Returns:</span>
<span class="sd">            Union[np.ndarray, torch.Tensor]: an adjacency matrix representation of this ``CFG``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.mem_cfg</span> <span class="kn">import</span> <span class="n">MemCFG</span>
        <span class="k">return</span> <span class="n">MemCFG</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalizer</span><span class="o">=</span><span class="s1">&#39;base&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalizer</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">to_adjacency_matrix</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="n">sparse</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="CFG.get_compressed_stats"><a class="viewcode-back" href="../../../bincfg.cfg.html#bincfg.cfg.cfg.CFG.get_compressed_stats">[docs]</a>    <span class="k">def</span> <span class="nf">get_compressed_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns some stats about this CFG in a compressed version</span>
<span class="sd">        </span>
<span class="sd">        These are meant to be very basic stats useful for simple comparisons (EG: dataset subsampling). These values</span>
<span class="sd">        are highly compressed/convoluted as they are used for generating statistics on 100+ million cfg&#39;s on HPC, and </span>
<span class="sd">        thus output space requirements outweigh single-graph compute time. Will return a single numpy array </span>
<span class="sd">        (1-d, dtype=np.uint8) with indices/values:</span>

<span class="sd">            - [0:12]: graph-level stats (number of nodes, number of functions, number of assembly lines), each a 4-byte </span>
<span class="sd">              unsigned integer of the exact value in the above order. The bytes are always stored as little-endian.</span>

<span class="sd">            - [12:20]: node degree histogram. Counts the number of nodes with degrees: 0 incomming, 1 incomming, 2 incomming,</span>
<span class="sd">              3+ incomming, 0 outgoing, 1 outgoing, 2 outgoing, 3+ outgoing. See below in things that are not</span>
<span class="sd">              in these stats for reasoning. Values will be a list in the above order:</span>

<span class="sd">              [0-in, 1-in, 2-in, 3+in, 0-out, 1-out, 2-out, 3+out]</span>

<span class="sd">              Reasoning: the vast majority of all nodes will have 0, 1 or 2 incomming normal edges, and 0, 1, or 2 outgoing</span>
<span class="sd">              normal edges, so this should be a fine way of storing that data for my purposes. Function call edges will</span>
<span class="sd">              be handled by the function degrees.</span>

<span class="sd">            - [20:46]: a histogram of node sizes (number of assembly lines per node). Histogram bins (left-inclusive, </span>
<span class="sd">              right-exclusive, 26 of them) will be:</span>

<span class="sd">              [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 16, 18, 20, 25, 30, 35, 40, 50, 60, 80, 100, 150, 200+]</span>

<span class="sd">              Reasoning: different compiler optimizations (inlining, loop unrolling, AVX instructions, etc.) will likely</span>
<span class="sd">              drastically change the sizes of nodes. The histogram bin edges were chosen arbitrarily in a way that tickled</span>
<span class="sd">              my non-neurotypical, nice-number-loving brain.</span>

<span class="sd">            - [46:72]: a histogram of (undirected) function degrees (in the function call graph). Histogram bins </span>
<span class="sd">              (left-inclusive, right-exclusive, 26 of them) will be:</span>

<span class="sd">              [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 16, 18, 20, 25, 30, 35, 40, 50, 60, 80, 100, 150, 200+]</span>

<span class="sd">              Reasoning: most functions will only be called a relatively small number of unique times across the </span>
<span class="sd">              binary (EG: &lt;10), while those that are called much more are likely</span>

<span class="sd">            - [72:93]: a histogram of function sizes (number of nodes in each function). Histogram bins (left-inclusive, </span>
<span class="sd">              right-exclusive, 21 of them) will be:</span>

<span class="sd">              [0, 1, 2, 3, 4, 6, 8, 10, 15, 20, 25, 30, 40, 60, 80, 100, 150, 200, 300, 400, 500+]</span>
<span class="sd">              </span>
<span class="sd">              Reasoning: different compiler optimizations (especially inlining) will drastically change the size of </span>
<span class="sd">              functions. The histogram bins can be more spread out (IE: not as focused on values near 0, and across</span>
<span class="sd">              a larger range) since the number of nodes in a function has a noticeably different distribution than,</span>
<span class="sd">              say, the histogram of node sizes</span>

<span class="sd">            - [93:]: a histogram of assembly tokens. One value per token. You should make sure the normalization method</span>
<span class="sd">              you are using is good, and doesn&#39;t create too many unique tokens.</span>
<span class="sd">              </span>
<span class="sd">              Reasoning: obvious</span>
<span class="sd">        </span>
<span class="sd">        The returned array will be of varrying length based on the number of unique tokens in the tokens dictionary.</span>
<span class="sd">        </span>
<span class="sd">        Values above (unless otherwise stated) are stored as 1-byte percentages of the number of nodes in the graph that</span>
<span class="sd">        are in that bin. EG: 0 would mean there are 0 nodes with that value, 1 would mean between [0, 1/255) of the </span>
<span class="sd">        nodes/functions in the graph have that value, 2 would be between [1/255, 2/255), etc., until a 255 which would</span>
<span class="sd">        be [245/255, 1.0]</span>
<span class="sd">        </span>
<span class="sd">        Things that are NOT in these stats and reasons:</span>

<span class="sd">            - Other node degrees: these likely don&#39;t change too much between programs (specifically their normalized values)</span>
<span class="sd">              as even with different programs/compiler optimizations. Changes between cfg&#39;s will likely only change the </span>
<span class="sd">              relative proportions of nodes with 1 vs. 2 incoming edges, and those with 1 vs. 2 vs. 3 outgoing edges. Any</span>
<span class="sd">              other number of edges are pretty rare, hence why we only keep those edge measures and only those using </span>
<span class="sd">              normal edges (since function call edges will be gathered in the func_degree_hist and would mess with this premise)</span>
<span class="sd">            - Edge statistics (EG: number of normal vs. function call edges): this information is partially hidden in the</span>
<span class="sd">              histograms already present, and exact values do not seem too important</span>
<span class="sd">            - Other centrality measures: I belive (but have not proven) that node-based centrality measures would not</span>
<span class="sd">              contain enough information to display differences between CFG&#39;s to be worth it. Because of the linear</span>
<span class="sd">              nature of sequential programs, I believe their centrality measures would be largely similar and/or</span>
<span class="sd">              dependant on other graph features already present in the stats above (EG: number of nodes in a function).</span>
<span class="sd">              I think any differences between centrality measurements on these graphs will be mostly washed out by the</span>
<span class="sd">              linear nature, especially since we would only be looking at normal edges, not function call ones. The only</span>
<span class="sd">              differences that would be highlighted would be information about the number of branches/loops in each</span>
<span class="sd">              function (which is already partially covered by the assembly line info), and a small amount of information</span>
<span class="sd">              on where within functions these branches tend to occur. However, combining these features into graph-level</span>
<span class="sd">              statistics would likely dilute these differences even further. It may, however, be useful to include one</span>
<span class="sd">              or more of these measures on the function call graph, but I am on the fence about its usefulness vs extra</span>
<span class="sd">              computation time/space required. I think for my purposes, the stats above work just fine</span>
<span class="sd">            </span>
<span class="sd">        Args:</span>
<span class="sd">            tokens (Union[Dict[str, int], AtomicData]): the token dictionary to use and possibly add to. Can also be</span>
<span class="sd">                an AtomicData object for atomic token dictionary file.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: the compressed stats, a numpy 1-d uint8 array of shape (97 + len(tokens), )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the token histogram</span>
        <span class="n">token_counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asm_counts</span>

        <span class="c1"># Create the token dictionary and update it with the new tokens</span>
        <span class="n">token_dict</span> <span class="o">=</span> <span class="n">tokens</span> <span class="k">if</span> <span class="n">tokens</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">token_dict</span><span class="p">,</span> <span class="n">AtomicTokenDict</span><span class="p">):</span>
            <span class="n">token_dict</span><span class="o">.</span><span class="n">addtokens</span><span class="p">({</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">token_counts</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">token_dict</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">token_counts</span><span class="p">:</span>
                <span class="n">token_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">token_dict</span><span class="p">))</span>

        <span class="c1"># Make sure this starts off a bit larger than the final length. I think the current val would be 97, but I made</span>
        <span class="c1">#   it a little larger for some more wiggle room. The correct size is returned anyways</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">100</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">token_dict</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">curr_idx</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Adding graph statistics as multi-byte unsigned integer values</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="n">GLS_DTYPE</span><span class="p">()</span><span class="o">.</span><span class="n">nbytes</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">GRAPH_LEVEL_STATS_FUNCS</span><span class="p">:</span>
            <span class="n">ret</span><span class="p">[</span><span class="n">curr_idx</span><span class="p">:</span> <span class="n">curr_idx</span> <span class="o">+</span> <span class="n">nb</span><span class="p">]</span> <span class="o">=</span>  <span class="n">_get_np_int_as_little_endian_list</span><span class="p">(</span><span class="n">GLS_DTYPE</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
            <span class="n">curr_idx</span> <span class="o">+=</span> <span class="n">nb</span>

        <span class="c1"># Get the node degree histograms</span>
        <span class="n">in_0</span><span class="p">,</span> <span class="n">in_1</span><span class="p">,</span> <span class="n">in_2</span><span class="p">,</span> <span class="n">in_other</span><span class="p">,</span> <span class="n">out_0</span><span class="p">,</span> <span class="n">out_1</span><span class="p">,</span> <span class="n">out_2</span><span class="p">,</span> <span class="n">out_other</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="p">:</span>
            <span class="n">n_in</span><span class="p">,</span> <span class="n">n_out</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">get_sorted_edges</span><span class="p">(</span><span class="n">edge_types</span><span class="o">=</span><span class="n">EdgeType</span><span class="o">.</span><span class="n">NORMAL</span><span class="p">)</span>

            <span class="c1"># Check edges in</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_in</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">in_0</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_in</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">in_1</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_in</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">in_2</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">in_other</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Check edges out</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_out</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">out_0</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_out</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">out_1</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_out</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">out_2</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out_other</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="n">num_blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_blocks</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="n">in_0</span><span class="p">,</span> <span class="n">in_1</span><span class="p">,</span> <span class="n">in_2</span><span class="p">,</span> <span class="n">in_other</span><span class="p">,</span> <span class="n">out_0</span><span class="p">,</span> <span class="n">out_1</span><span class="p">,</span> <span class="n">out_2</span><span class="p">,</span> <span class="n">out_other</span><span class="p">]:</span>
            <span class="n">ret</span><span class="p">[</span><span class="n">curr_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">_get_single_byte_ratio</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">num_blocks</span><span class="p">)</span>
            <span class="n">curr_idx</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Get the node size histogram</span>
        <span class="n">curr_idx</span> <span class="o">=</span> <span class="n">_get_single_byte_histogram</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">asm_lines</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocks_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()],</span> 
            <span class="n">NODE_SIZE_HIST_BINS</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">curr_idx</span><span class="p">)</span>

        <span class="c1"># Get the function undirected degree histogram</span>
        <span class="n">curr_idx</span> <span class="o">=</span> <span class="n">_get_single_byte_histogram</span><span class="p">([</span><span class="n">f</span><span class="o">.</span><span class="n">num_fc_edges</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()],</span> 
            <span class="n">FUNCTION_DEGREE_HIST_BINS</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">curr_idx</span><span class="p">)</span>
        
        <span class="c1"># Get the function size histogram</span>
        <span class="n">curr_idx</span> <span class="o">=</span> <span class="n">_get_single_byte_histogram</span><span class="p">([</span><span class="n">f</span><span class="o">.</span><span class="n">num_blocks</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()],</span>
            <span class="n">FUNCTION_SIZE_HIST_BINS</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">curr_idx</span><span class="p">)</span>
        
        <span class="c1"># Get the asm line histogram</span>
        <span class="c1"># Invert the token dict to get a mapping from index to asm line</span>
        <span class="n">inv_token_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">token_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">num_asm_lines</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">token_counts</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">ret</span><span class="p">[</span><span class="n">curr_idx</span><span class="p">:</span> <span class="n">curr_idx</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">inv_token_dict</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="n">_get_single_byte_ratio</span><span class="p">(</span><span class="n">token_counts</span><span class="p">[</span><span class="n">inv_token_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">num_asm_lines</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inv_token_dict</span><span class="p">))]</span>
        <span class="n">curr_idx</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">inv_token_dict</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span><span class="p">[:</span><span class="n">curr_idx</span><span class="p">]</span></div>
    
<div class="viewcode-block" id="CFG.uncompress_stats"><a class="viewcode-back" href="../../../bincfg.cfg.html#bincfg.cfg.cfg.CFG.uncompress_stats">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">uncompress_stats</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Uncompressed the stats from cfg.get_compressed_stats()</span>
<span class="sd">        </span>
<span class="sd">        Will return a numpy array with specified dtype (defaults to np.uint32) of stats in the same order they appreared </span>
<span class="sd">        in get_compressed_stats(). The size will decrease by around 12 indices as the initial 4-byte values are converted</span>
<span class="sd">        back into a one-index integer.</span>

<span class="sd">        Args:</span>
<span class="sd">            stats (np.ndarray): either a 1-d or 2-d numpy array of stats. If 2-d, then it is assumed that these are multiple</span>
<span class="sd">                stats for multiple cfgs, one cfg per row</span>
<span class="sd">            dtype (np.dtype): the numpy dtype to return as. Defaults to np.uint32</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: either a 1-d or 2-d numpy array of uncompressed stats, depending on what was passed to `stats`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">stats</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`stats` array must have dimension 1 or 2, not </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">stats</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
        
        <span class="c1"># Get the return array, removing the elements for the multi-byte ints. Determine what dimension to be using</span>
        <span class="k">if</span> <span class="n">stats</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">stats</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">stats</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">GRAPH_LEVEL_STATS_FUNCS</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">GLS_DTYPE</span><span class="p">()</span><span class="o">.</span><span class="n">nbytes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
            <span class="n">ret_one_dim</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">stats</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">GRAPH_LEVEL_STATS_FUNCS</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">GLS_DTYPE</span><span class="p">()</span><span class="o">.</span><span class="n">nbytes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
            <span class="n">stats</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats</span><span class="p">]</span>
            <span class="n">ret_one_dim</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Iterate through all rows in stats to uncompress</span>
        <span class="k">for</span> <span class="n">row_idx</span><span class="p">,</span> <span class="n">stat_arr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stats</span><span class="p">):</span>
            <span class="n">stats_idx</span> <span class="o">=</span> <span class="n">ret_idx</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># Unpack the multi-byte ints</span>
            <span class="n">nb</span> <span class="o">=</span> <span class="n">GLS_DTYPE</span><span class="p">()</span><span class="o">.</span><span class="n">nbytes</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">GRAPH_LEVEL_STATS_FUNCS</span><span class="p">:</span>
                <span class="n">ret</span><span class="p">[</span><span class="n">row_idx</span><span class="p">,</span> <span class="n">ret_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">_get_np_int_from_little_endian_list</span><span class="p">(</span><span class="n">stat_arr</span><span class="p">[</span><span class="n">stats_idx</span><span class="p">:</span> <span class="n">stats_idx</span> <span class="o">+</span> <span class="n">nb</span><span class="p">])</span>
                <span class="n">stats_idx</span> <span class="o">+=</span> <span class="n">nb</span>
                <span class="n">ret_idx</span> <span class="o">+=</span> <span class="mi">1</span>
            
            <span class="n">num_blocks</span><span class="p">,</span> <span class="n">num_functions</span><span class="p">,</span> <span class="n">num_asm_lines</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="n">row_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>

            <span class="c1"># Unpack the histograms: node degrees, node sizes, function degrees, function sizes, asm lines</span>
            <span class="n">ret_idx</span><span class="p">,</span> <span class="n">stats_idx</span> <span class="o">=</span> <span class="n">_uncompress_hist</span><span class="p">(</span><span class="n">row_idx</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">stat_arr</span><span class="p">[</span><span class="n">stats_idx</span><span class="p">:</span> <span class="n">stats_idx</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">ret_idx</span><span class="p">,</span> <span class="n">stats_idx</span><span class="p">,</span> <span class="n">num_blocks</span><span class="p">)</span>
            <span class="n">ret_idx</span><span class="p">,</span> <span class="n">stats_idx</span> <span class="o">=</span> <span class="n">_uncompress_hist</span><span class="p">(</span><span class="n">row_idx</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">stat_arr</span><span class="p">[</span><span class="n">stats_idx</span><span class="p">:</span> <span class="n">stats_idx</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">NODE_SIZE_HIST_BINS</span><span class="p">)],</span> <span class="n">ret_idx</span><span class="p">,</span> <span class="n">stats_idx</span><span class="p">,</span> <span class="n">num_blocks</span><span class="p">)</span>
            <span class="n">ret_idx</span><span class="p">,</span> <span class="n">stats_idx</span> <span class="o">=</span> <span class="n">_uncompress_hist</span><span class="p">(</span><span class="n">row_idx</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">stat_arr</span><span class="p">[</span><span class="n">stats_idx</span><span class="p">:</span> <span class="n">stats_idx</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">FUNCTION_DEGREE_HIST_BINS</span><span class="p">)],</span> <span class="n">ret_idx</span><span class="p">,</span> <span class="n">stats_idx</span><span class="p">,</span> <span class="n">num_functions</span><span class="p">)</span>
            <span class="n">ret_idx</span><span class="p">,</span> <span class="n">stats_idx</span> <span class="o">=</span> <span class="n">_uncompress_hist</span><span class="p">(</span><span class="n">row_idx</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">stat_arr</span><span class="p">[</span><span class="n">stats_idx</span><span class="p">:</span> <span class="n">stats_idx</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">FUNCTION_SIZE_HIST_BINS</span><span class="p">)],</span> <span class="n">ret_idx</span><span class="p">,</span> <span class="n">stats_idx</span><span class="p">,</span> <span class="n">num_functions</span><span class="p">)</span>
            <span class="n">ret_idx</span><span class="p">,</span> <span class="n">stats_idx</span> <span class="o">=</span> <span class="n">_uncompress_hist</span><span class="p">(</span><span class="n">row_idx</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">stat_arr</span><span class="p">[</span><span class="n">stats_idx</span><span class="p">:],</span> <span class="n">ret_idx</span><span class="p">,</span> <span class="n">stats_idx</span><span class="p">,</span> <span class="n">num_asm_lines</span><span class="p">)</span>

        <span class="c1"># Return a 1-d if needed</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="n">ret_one_dim</span> <span class="k">else</span> <span class="n">ret</span>
        <span class="k">return</span> <span class="n">ret</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="CFG.normalize"><a class="viewcode-back" href="../../../bincfg.cfg.html#bincfg.cfg.cfg.CFG.normalize">[docs]</a>    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalizer</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">force_renormalize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Normalizes this cfg in-place.</span>

<span class="sd">        Args:</span>
<span class="sd">            normalizer (Union[str, Normalizer], optional): the normalizer to use. Can be a ``Normalizer`` object, or a </span>
<span class="sd">                string of a built-in normalizer to use.</span>
<span class="sd">            inplace (bool, optional): whether or not to normalize inplace. Defaults to True.</span>
<span class="sd">            force_renormalize (bool, optional): by default, this method will only normalize this cfg if the passed </span>
<span class="sd">                `normalizer` is != `self.normalizer`. However if `force_renormalize=True`, then this will be renormalized</span>
<span class="sd">                even if it has been previously normalized with the same normalizer. Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            CFG: this ``CFG`` normalized</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">normalize_cfg_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalizer</span><span class="o">=</span><span class="n">normalizer</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="n">force_renormalize</span><span class="o">=</span><span class="n">force_renormalize</span><span class="p">)</span></div>

<div class="viewcode-block" id="CFG.to_networkx"><a class="viewcode-back" href="../../../bincfg.cfg.html#bincfg.cfg.cfg.CFG.to_networkx">[docs]</a>    <span class="k">def</span> <span class="nf">to_networkx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts this CFG to a networkx DiGraph() object</span>
<span class="sd">        </span>
<span class="sd">        Requires that networkx be installed.</span>

<span class="sd">        Creates a new MultiDiGraph() and adds as attributes to that graph:</span>

<span class="sd">            - &#39;normalizer&#39;: string name of normalizer, or None if it had none</span>
<span class="sd">            - &#39;metadata&#39;: a dictionary of metadata</span>
<span class="sd">            - functions: a dictionary mapping integer function addresses to named tuples containing its data with the</span>
<span class="sd">              structure (&#39;name&#39;: Union[str, None], &#39;is_extern_func&#39;: bool, &#39;blocks&#39;: Tuple[int, ...]).</span>

<span class="sd">                * The &#39;name&#39; element (first element) is a string name of the function, or None if it doesn&#39;t have a name</span>
<span class="sd">                * The &#39;is_extern_func&#39; element (second element) is True if this function is an extern function, False otherwise.</span>
<span class="sd">                  An extern function is one that is located in an external library intended to be found at runtime, and</span>
<span class="sd">                  that doesn&#39;t have its code here in the CFG, only a small function meant to jump to the external function</span>
<span class="sd">                  when loaded at runtime</span>
<span class="sd">                * The &#39;blocks&#39; element (third element) is an arbitrary-length tuple of integers, each integer being the</span>
<span class="sd">                  memory address (equivalently, the block_id) of a basic block that is a part of that function. Each</span>
<span class="sd">                  basic block is only part of a single function, and each function should have at least one basic block</span>
<span class="sd">            </span>
<span class="sd">              NOTE: the ADDRESS value will be and uppercase hex starting with a &#39;0x&#39;</span>
<span class="sd">        </span>
<span class="sd">        NOTE: we use a multidigraph because edges are directed (in order of control flow), and it is theoretically</span>
<span class="sd">        possible (and occurs in some data) to have a node that calls another node, then has a normal edge back out</span>
<span class="sd">        to it. This has occured in some libc setup code</span>
<span class="sd">        </span>
<span class="sd">        Then, each basic block will be added to the graph as nodes. Their id in the graph will be their integer address.</span>
<span class="sd">        Each block will have the following attributes:</span>

<span class="sd">            - &#39;asm_lines&#39; (Tuple[Tuple[int, str]]): tuple of assembly lines. Each assembly line is a (address, line)</span>
<span class="sd">              tuple where `address` is the integer address of that assembly line, and `line` is a cleaned, space-separated</span>
<span class="sd">              string of tokens in that assembly line</span>
<span class="sd">            - &#39;labels&#39; (Set[str]): a set of string labels for nodes, empty meaning it is unlabeled</span>
<span class="sd">        </span>
<span class="sd">        Finally, all edges will be added (directed based on control flow direction), and with the attributes:</span>

<span class="sd">            - &#39;edge_type&#39; (str): the edge type, will be &#39;normal&#39; for normal edges and &#39;function_call&#39; for function call</span>
<span class="sd">              edges</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Done like this so I have IDE autocomplete while making sure the package is installed</span>
        <span class="n">_netx</span> <span class="o">=</span> <span class="n">get_module</span><span class="p">(</span><span class="s1">&#39;networkx&#39;</span><span class="p">,</span> <span class="n">raise_err</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="kn">import</span> <span class="nn">networkx</span>

        <span class="c1"># Add all of the functions to a dictionary to set as an attribute on the graph</span>
        <span class="n">functions</span> <span class="o">=</span> <span class="p">{</span><span class="n">func</span><span class="o">.</span><span class="n">address</span><span class="p">:</span> <span class="n">_NetXTuple</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="n">_is_extern_function</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">address</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">func</span><span class="o">.</span><span class="n">blocks</span><span class="p">))</span>
                     <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()}</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">(</span><span class="n">normalizer</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalizer</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalizer</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;normalizer&quot;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span>
                             <span class="n">functions</span><span class="o">=</span><span class="n">functions</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>
        
        <span class="c1"># Add all of the blocks to the graph</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocks_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="n">NODE_LABELS_INT_TO_STR</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">labels</span><span class="p">),</span>
                         <span class="n">asm_lines</span><span class="o">=</span><span class="nb">tuple</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">l</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">asm_lines</span><span class="p">))</span>
        
        <span class="c1"># Finally, add all the edges</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">from_block</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">to_block</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">edge</span><span class="o">.</span><span class="n">edge_type</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
        
        <span class="k">return</span> <span class="n">ret</span></div>
    
<div class="viewcode-block" id="CFG.from_networkx"><a class="viewcode-back" href="../../../bincfg.cfg.html#bincfg.cfg.cfg.CFG.from_networkx">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_networkx</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">cfg</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts a networkx graph to a CFG</span>

<span class="sd">        Expects the graph to have the exact same structure as is shown in CFG().to_networkx()</span>

<span class="sd">        You can optionally pass a cfg, in which case this data will be added to (and override) that cfg</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cfg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">CFG</span><span class="p">(</span><span class="n">normalizer</span><span class="o">=</span><span class="n">graph</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;normalizer&#39;</span><span class="p">],</span> <span class="n">metadata</span><span class="o">=</span><span class="n">graph</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;metadata&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">cfg</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;metadata&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;normalizer&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;normalizer&#39;</span><span class="p">])</span>

        <span class="n">ret</span><span class="o">.</span><span class="n">add_function</span><span class="p">(</span><span class="o">*</span><span class="p">[</span>
            <span class="n">CFGFunction</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="n">addr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">is_extern_func</span><span class="o">=</span><span class="n">ef</span><span class="p">,</span> <span class="n">blocks</span><span class="o">=</span><span class="p">[</span>
                <span class="n">CFGBasicBlock</span><span class="p">(</span>
                    <span class="n">address</span><span class="o">=</span><span class="n">block_addr</span><span class="p">,</span>
                    <span class="n">labels</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="n">NODE_LABELS_STR_TO_INT</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">block_addr</span><span class="p">][</span><span class="s1">&#39;labels&#39;</span><span class="p">]),</span>
                    <span class="n">edges_out</span><span class="o">=</span><span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">et</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">et</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">block_addr</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">)],</span>
                    <span class="n">asm_lines</span><span class="o">=</span><span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span> <span class="k">if</span> <span class="n">ret</span><span class="o">.</span><span class="n">normalizer</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">block_addr</span><span class="p">][</span><span class="s1">&#39;asm_lines&#39;</span><span class="p">]]</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">block_addr</span> <span class="ow">in</span> <span class="n">blocks</span>
            <span class="p">])</span>
            <span class="k">for</span> <span class="n">addr</span><span class="p">,</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ef</span><span class="p">,</span> <span class="n">blocks</span><span class="p">)</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;functions&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">])</span>

        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="CFG.to_cfg_dict"><a class="viewcode-back" href="../../../bincfg.cfg.html#bincfg.cfg.cfg.CFG.to_cfg_dict">[docs]</a>    <span class="k">def</span> <span class="nf">to_cfg_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts this cfg to a dictionary of cfg information</span>
<span class="sd">        </span>
<span class="sd">        The cfg dictionary will have the structure::</span>

<span class="sd">            {</span>
<span class="sd">                &#39;normalizer&#39;: the string name of the normalizer used,</span>
<span class="sd">                &#39;metadata&#39;: a dictionary of metadata,</span>
<span class="sd">                &#39;functions&#39;: {</span>
<span class="sd">                </span>
<span class="sd">                    func_address_1: {</span>
<span class="sd">                        &#39;name&#39; (str): string name of the function, or None if it has no name,</span>
<span class="sd">                        &#39;is_extern_func&#39; (bool): True if this function is an extern function, False otherwise.</span>
<span class="sd">                            An extern function is one that is located in an external library intended to be found at </span>
<span class="sd">                            runtime, and that doesn&#39;t have its code here in the CFG, only a small function meant to jump to </span>
<span class="sd">                            the external function when loaded at runtime</span>

<span class="sd">                        &#39;blocks&#39;: {</span>
<span class="sd">                            block_address_1: {</span>
<span class="sd">                                &#39;labels&#39; (Set[str]): a set of string labels for nodes, empty meaning it is unlabeled</span>
<span class="sd">                                &#39;edges_out&#39; (Tuple[Tuple[int, str], ...]): tuple of all outgoing edges. Each &#39;edge&#39; is a tuple</span>
<span class="sd">                                    of (other_basic_block_address: int, edge_type: str), where `edge_type` can be &#39;normal&#39;</span>
<span class="sd">                                    for a normal edge and &#39;function_call&#39; for a function call edge</span>
<span class="sd">                                &#39;asm_lines&#39; (Tuple[Tuple[int, str], ...]): tuple of all assembly lines in this block. Each </span>
<span class="sd">                                    assembly line is a (address, line) tuple where `address` is the integer address of that </span>
<span class="sd">                                    assembly line, and `line` is a cleaned, space-separated string of tokens in that assembly </span>
<span class="sd">                                    line</span>
<span class="sd">                            },</span>

<span class="sd">                            block_address_1: ...,</span>
<span class="sd">                            ...</span>
<span class="sd">                        }</span>

<span class="sd">                    },</span>

<span class="sd">                    func_address_2: ...,</span>
<span class="sd">                    ...</span>
<span class="sd">                }</span>
<span class="sd">            }</span>

<span class="sd">        - func_address_X: integer address of that function</span>
<span class="sd">        - block_address_X: integer address of that block</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;normalizer&#39;</span><span class="p">:</span>  <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalizer</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalizer</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;normalizer&quot;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span>
            <span class="s1">&#39;metadata&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span>
            <span class="s1">&#39;functions&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="n">func</span><span class="o">.</span><span class="n">address</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">func</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="s1">&#39;is_extern_func&#39;</span><span class="p">:</span> <span class="n">func</span><span class="o">.</span><span class="n">_is_extern_function</span><span class="p">,</span>
                    <span class="s1">&#39;blocks&#39;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="n">block</span><span class="o">.</span><span class="n">address</span><span class="p">:</span> <span class="p">{</span>
                            <span class="s1">&#39;labels&#39;</span><span class="p">:</span> <span class="nb">set</span><span class="p">(</span><span class="n">NODE_LABELS_INT_TO_STR</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">labels</span><span class="p">),</span>
                            <span class="s1">&#39;edges_out&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">e</span><span class="o">.</span><span class="n">to_block</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">edge_type</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">edges_out</span><span class="p">),</span>
                            <span class="s1">&#39;asm_lines&#39;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">l</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">asm_lines</span><span class="p">)</span>
                        <span class="p">}</span>
                        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">func</span><span class="o">.</span><span class="n">blocks</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span>
            <span class="p">}</span>
        <span class="p">}</span></div>
    
<div class="viewcode-block" id="CFG.from_cfg_dict"><a class="viewcode-back" href="../../../bincfg.cfg.html#bincfg.cfg.cfg.CFG.from_cfg_dict">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_cfg_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">cfg_dict</span><span class="p">,</span> <span class="n">cfg</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts a cfg dict object into a CFG</span>
<span class="sd">        </span>
<span class="sd">        Expects the cfg_dict to have the exact same structure as that listed in CFG().to_cfg_dict()</span>

<span class="sd">        You can optionally pass a cfg, in which case this data will be added to (and override) that cfg</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cfg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">CFG</span><span class="p">(</span><span class="n">normalizer</span><span class="o">=</span><span class="n">cfg_dict</span><span class="p">[</span><span class="s1">&#39;normalizer&#39;</span><span class="p">],</span> <span class="n">metadata</span><span class="o">=</span><span class="n">cfg_dict</span><span class="p">[</span><span class="s1">&#39;metadata&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">cfg</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cfg_dict</span><span class="p">[</span><span class="s1">&#39;metadata&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">cfg_dict</span><span class="p">[</span><span class="s1">&#39;normalizer&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">cfg_dict</span><span class="p">[</span><span class="s1">&#39;normalizer&#39;</span><span class="p">])</span>

        <span class="n">ret</span><span class="o">.</span><span class="n">add_function</span><span class="p">(</span><span class="o">*</span><span class="p">[</span>
            <span class="n">CFGFunction</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="n">func_addr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">func_dict</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">is_extern_func</span><span class="o">=</span><span class="n">func_dict</span><span class="p">[</span><span class="s1">&#39;is_extern_func&#39;</span><span class="p">],</span> <span class="n">blocks</span><span class="o">=</span><span class="p">[</span>
                <span class="n">CFGBasicBlock</span><span class="p">(</span>
                    <span class="n">address</span><span class="o">=</span><span class="n">block_addr</span><span class="p">,</span>
                    <span class="n">labels</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="n">NODE_LABELS_STR_TO_INT</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">block_dict</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]),</span>
                    <span class="n">edges_out</span><span class="o">=</span><span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">et</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">et</span> <span class="ow">in</span> <span class="n">block_dict</span><span class="p">[</span><span class="s1">&#39;edges_out&#39;</span><span class="p">]],</span>
                    <span class="n">asm_lines</span><span class="o">=</span><span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span> <span class="k">if</span> <span class="n">ret</span><span class="o">.</span><span class="n">normalizer</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> \
                                    <span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="k">if</span> <span class="n">ret</span><span class="o">.</span><span class="n">normalizer</span><span class="o">.</span><span class="n">tokenization_level</span> <span class="o">==</span> <span class="n">TokenizationLevel</span><span class="o">.</span><span class="n">INSTRUCTION</span> <span class="k">else</span> \
                                    <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">block_dict</span><span class="p">[</span><span class="s1">&#39;asm_lines&#39;</span><span class="p">]]</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">block_addr</span><span class="p">,</span> <span class="n">block_dict</span> <span class="ow">in</span> <span class="n">func_dict</span><span class="p">[</span><span class="s1">&#39;blocks&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">])</span>
            <span class="k">for</span> <span class="n">func_addr</span><span class="p">,</span> <span class="n">func_dict</span> <span class="ow">in</span> <span class="n">cfg_dict</span><span class="p">[</span><span class="s1">&#39;functions&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">])</span>

        <span class="k">return</span> <span class="n">ret</span></div>
    
<div class="viewcode-block" id="CFG.save"><a class="viewcode-back" href="../../../bincfg.cfg.html#bincfg.cfg.cfg.CFG.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Saves this CFG to path&quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="CFG.load"><a class="viewcode-back" href="../../../bincfg.cfg.html#bincfg.cfg.cfg.CFG.load">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Loads this CFG from path&quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span></div>
    
    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;State for pickling</span>
<span class="sd">        </span>
<span class="sd">        Pickling should be done like so:</span>

<span class="sd">            - normalizers are wrapped with _Pickled_Normalizer() object</span>
<span class="sd">            - edges are converted into 3-tuples of (from_address: int, to_address: int, edge_type: EdgeType) (done in</span>
<span class="sd">              CFGBasicBlock)</span>
<span class="sd">            - references to parent_objects are removed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;functions_dict&#39;</span><span class="p">,</span> <span class="s1">&#39;blocks_dict&#39;</span><span class="p">,</span> <span class="s1">&#39;_inst_lookup&#39;</span><span class="p">]}</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;normalizer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_Pickled_Normalizer</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s1">&#39;normalizer&#39;</span><span class="p">])</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;functions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">_get_pickle_state</span><span class="p">()</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">state</span>
    
    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;State for unpickling&quot;&quot;&quot;</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;normalizer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;normalizer&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unpickle</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;functions&#39;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">functions_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">func_addr</span><span class="p">:</span> <span class="n">CFGFunction</span><span class="p">(</span><span class="n">parent_cfg</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_set_pickle_state</span><span class="p">([</span><span class="n">func_addr</span><span class="p">,]</span> <span class="o">+</span> <span class="n">rest</span><span class="p">)</span> <span class="k">for</span> <span class="n">func_addr</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span> <span class="ow">in</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;functions&#39;</span><span class="p">]}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blocks_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">b</span><span class="o">.</span><span class="n">address</span><span class="p">:</span> <span class="n">b</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">blocks</span><span class="p">}</span>
        
        <span class="c1"># Recreate all the edges</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">e</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocks_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">_temp_edges_in</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">_temp_edges_out</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">from_addr</span><span class="p">,</span> <span class="n">to_addr</span><span class="p">,</span> <span class="n">edge_type</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="n">CFGEdge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_block</span><span class="p">(</span><span class="n">from_addr</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_block</span><span class="p">(</span><span class="n">to_addr</span><span class="p">),</span> <span class="n">edge_type</span><span class="p">)</span>
            <span class="n">edge</span><span class="o">.</span><span class="n">from_block</span><span class="o">.</span><span class="n">edges_out</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
            <span class="n">edge</span><span class="o">.</span><span class="n">to_block</span><span class="o">.</span><span class="n">edges_in</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
        
        <span class="c1"># Delete the _temp_edges attributes for all blocks</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocks_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="s1">&#39;_temp_edges_in&#39;</span><span class="p">):</span>
                <span class="k">del</span> <span class="n">block</span><span class="o">.</span><span class="n">_temp_edges_in</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="s1">&#39;_temp_edges_out&#39;</span><span class="p">):</span>
                <span class="k">del</span> <span class="n">block</span><span class="o">.</span><span class="n">_temp_edges_out</span>
    
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">CFG</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">eq_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">selector</span><span class="o">=</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;normalizer&#39;</span><span class="p">,</span> <span class="s1">&#39;functions_dict&#39;</span><span class="p">,</span> <span class="s1">&#39;metadata&#39;</span><span class="p">])</span>
    
    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">*</span> <span class="mi">7</span> <span class="o">+</span> <span class="n">hash_obj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> <span class="n">return_int</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">*</span> <span class="mi">17</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">norm_str</span> <span class="o">=</span> <span class="s1">&#39;no normalizer&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalizer</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="s1">&#39;normalizer: &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">normalizer</span><span class="p">)))</span>
        <span class="k">return</span> <span class="s2">&quot;CFG with </span><span class="si">%s</span><span class="s2"> and </span><span class="si">%d</span><span class="s2"> functions, </span><span class="si">%d</span><span class="s2"> basic blocks, </span><span class="si">%d</span><span class="s2"> edges, and </span><span class="si">%d</span><span class="s2"> lines of assembly</span><span class="se">\n</span><span class="s2">Metadata: </span><span class="si">%s</span><span class="s2">&quot;</span> \
            <span class="o">%</span> <span class="p">(</span><span class="n">norm_str</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functions_dict</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_blocks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_asm_lines</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
<div class="viewcode-block" id="CFG.get_cfg_build_code"><a class="viewcode-back" href="../../../bincfg.cfg.html#bincfg.cfg.cfg.CFG.get_cfg_build_code">[docs]</a>    <span class="k">def</span> <span class="nf">get_cfg_build_code</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns python code that will build the given cfg. Used for testing</span>

<span class="sd">        Args:</span>
<span class="sd">            cfg (CFG): the cfg</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            str: string of python code to build the cfg</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_functions</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">: CFGFunction(parent_cfg=__auto_cfg, address=</span><span class="si">%d</span><span class="s2">, name=</span><span class="si">%s</span><span class="s2">, is_extern_func=</span><span class="si">%s</span><span class="s2">),&quot;</span> <span class="o">%</span> 
            <span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="n">f</span><span class="o">.</span><span class="n">is_extern_function</span><span class="p">))</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">])</span>
        
        <span class="n">all_blocks</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: CFGBasicBlock(parent_function=__auto_functions[</span><span class="si">%d</span><span class="s2">], address=</span><span class="si">%d</span><span class="s2">, labels=</span><span class="si">%s</span><span class="s2">, asm_lines=[</span><span class="se">\n</span><span class="s2">        </span><span class="si">%s</span><span class="se">\n</span><span class="s2">    ]),&quot;</span> <span class="o">%</span> 
            <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">parent_function</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">labels</span><span class="p">),</span> 
                <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">        &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([(</span><span class="s2">&quot;(</span><span class="si">%d</span><span class="s2">, </span><span class="si">%s</span><span class="s2">),&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">inst</span><span class="p">)))</span> <span class="k">for</span> <span class="n">addr</span><span class="p">,</span> <span class="n">inst</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">asm_lines</span><span class="p">])</span>
            <span class="p">))</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="p">])</span>
        
        <span class="n">all_edges</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([(</span><span class="s2">&quot;__auto_blocks[</span><span class="si">%d</span><span class="s2">].edges_out = set([</span><span class="se">\n</span><span class="s2">    </span><span class="si">%s</span><span class="se">\n</span><span class="s2">])&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> 
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([(</span><span class="s2">&quot;CFGEdge(from_block=__auto_blocks[</span><span class="si">%d</span><span class="s2">], to_block=__auto_blocks[</span><span class="si">%d</span><span class="s2">], edge_type=EdgeType.</span><span class="si">%s</span><span class="s2">),&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">from_block</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">to_block</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">edge_type</span><span class="o">.</span><span class="n">name</span><span class="p">))</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">edges_out</span><span class="p">])</span>
        <span class="p">))</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="p">])</span>

        <span class="n">add_blocks</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([(</span><span class="s2">&quot;__auto_functions[</span><span class="si">%d</span><span class="s2">].blocks = set([</span><span class="se">\n</span><span class="s2">    </span><span class="si">%s</span><span class="se">\n</span><span class="s2">])&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([(</span><span class="s2">&quot;__auto_blocks[</span><span class="si">%d</span><span class="s2">],&quot;</span> <span class="o">%</span> <span class="n">b</span><span class="o">.</span><span class="n">address</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">blocks</span><span class="p">])</span>
        <span class="p">))</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">_CFG_BUILD_CODE_STR</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_functions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_blocks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_asm_lines</span><span class="p">,</span> <span class="n">all_functions</span><span class="p">,</span>
            <span class="n">all_blocks</span><span class="p">,</span> <span class="n">all_edges</span><span class="p">,</span> <span class="n">add_blocks</span><span class="p">)</span></div></div>


<span class="k">def</span> <span class="nf">_get_np_int_as_little_endian_list</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;returns a list of bytes for the given numpy integer in little-endian order&quot;&quot;&quot;</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span>

    <span class="c1"># Get the byte order and check if we need to swap endianness</span>
    <span class="n">bo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">GLS_DTYPE</span><span class="p">)</span><span class="o">.</span><span class="n">byteorder</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bo</span> <span class="o">==</span> <span class="s1">&#39;=&#39;</span> <span class="ow">and</span> <span class="n">sys</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">==</span> <span class="s1">&#39;big&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">bo</span> <span class="o">==</span> <span class="s1">&#39;&gt;&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ret</span>


<span class="k">def</span> <span class="nf">_get_np_int_from_little_endian_list</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a numpy integer from the given list of little-endian bytes</span>
<span class="sd">    </span>
<span class="sd">    NOTE: `l` MUST be either a python built-in (list/tuple/etc), or a numpy array with dtype np.uint8!</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;little&#39;</span><span class="p">,</span> <span class="n">signed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_single_byte_ratio</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">total</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes the ratio val/total (assumes total &gt;= val), and converts that resultant value to a byte</span>
<span class="sd">    </span>
<span class="sd">    The byte value will be determined based on what &#39;chunk&#39; in the range [0, 1] the value is, with there being 256</span>
<span class="sd">    available chunks for one byte. EG: 0 would mean val == 0, 1 would mean val is between [0, 1/255), 2 would be between</span>
<span class="sd">    [1/255, 2/255), etc., until a 255 which would be between [245/255, 1].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">total</span> <span class="o">&gt;=</span> <span class="n">val</span><span class="p">,</span> <span class="s2">&quot;Total was &lt; val! Total: </span><span class="si">%d</span><span class="s2">, val: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">total</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">val</span> <span class="o">/</span> <span class="n">total</span> <span class="o">*</span> <span class="mi">255</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_single_byte_histogram</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">curr_idx</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Does a full histogram thing</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        vals (Iterable[int]): the values to bin/histogram</span>
<span class="sd">        bins (Iterable[int]): the bins to use. Should start with the lowest value, and have right=False.</span>
<span class="sd">            EG: with bins [0, 3, 7, 9] and values [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], they would be digitized into</span>
<span class="sd">            [0, 0, 0, 1, 1, 1, 1, 2, 2, 3, 3]</span>
<span class="sd">        ret (np.ndarray): the values to insert into</span>
<span class="sd">        curr_idx (int): the index in ret to insert into</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        int: the starting index in ret to continue inserting values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">binned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">uniques</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">binned</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">ret</span><span class="p">[</span><span class="n">uniques</span> <span class="o">+</span> <span class="n">curr_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">_get_single_byte_ratio</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">binned</span><span class="p">))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">curr_idx</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_uncompress_hist</span><span class="p">(</span><span class="n">row_idx</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">ret_idx</span><span class="p">,</span> <span class="n">stats_idx</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Uncompresses histogram values, and returns new ret_idx and stats_idx, with `val` being the value that was used</span>
<span class="sd">    for the percentages (IE: self.num_blocks). Stores uncompressed values into ret (a 2-d array)&quot;&quot;&quot;</span>
    <span class="n">ret</span><span class="p">[</span><span class="n">row_idx</span><span class="p">,</span> <span class="n">ret_idx</span><span class="p">:</span> <span class="n">ret_idx</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">stats</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">stats</span> <span class="o">*</span> <span class="mi">1</span><span class="o">/</span><span class="mi">255</span> <span class="o">*</span> <span class="n">val</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret_idx</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">stats</span><span class="p">),</span> <span class="n">stats_idx</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">stats</span><span class="p">)</span>


<div class="viewcode-block" id="InvalidInsertionMemoryAddressError"><a class="viewcode-back" href="../../../bincfg.cfg.html#bincfg.cfg.cfg.InvalidInsertionMemoryAddressError">[docs]</a><span class="k">class</span> <span class="nc">InvalidInsertionMemoryAddressError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span></div>


<span class="c1"># NamedTuple used for conversion to networkx graph</span>
<span class="n">_NetXTuple</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;CFGFunctionDataTuple&#39;</span><span class="p">,</span> <span class="s1">&#39;name is_extern_func blocks&#39;</span><span class="p">)</span>

        
<span class="n">_CFG_BUILD_CODE_STR</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">##################</span>
<span class="s2"># AUTO-GENERATED #</span>
<span class="s2">##################</span>

<span class="s2"># Create the cfg object. This cfg has </span><span class="si">%d</span><span class="s2"> functions, </span><span class="si">%d</span><span class="s2"> basic blocks, </span><span class="si">%d</span><span class="s2"> edges, and </span><span class="si">%d</span><span class="s2"> lines of assembly.</span>
<span class="s2">__auto_cfg = CFG()</span>

<span class="s2"># Building all functions. Dictionary maps integer address to CFGFunction() object</span>
<span class="s2">__auto_functions = {</span>
<span class="s2">    </span><span class="si">%s</span><span class="s2"></span>
<span class="s2">}</span>

<span class="s2"># Building basic blocks. Dictionary maps integer address to CFGBasicBlock() object</span>
<span class="s2">__auto_blocks = {</span>
<span class="s2">    </span><span class="si">%s</span><span class="s2"></span>
<span class="s2">}</span>

<span class="s2"># Building all edges</span>
<span class="si">%s</span><span class="s2"></span>

<span class="s2"># Adding basic blocks to their associated functions</span>
<span class="si">%s</span><span class="s2"></span>

<span class="s2"># Adding functions to the cfg</span>
<span class="s2">__auto_cfg.add_function(*__auto_functions.values())</span>

<span class="s2">######################</span>
<span class="s2"># END AUTO-GENERATED #</span>
<span class="s2">######################</span>
<span class="s2">&quot;&quot;&quot;</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Justin Allen.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>